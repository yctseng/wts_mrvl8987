/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors ($B!H(BAuthorized Licensees$B!Ils ~/De	(B)..AN  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee$B!G(Bs proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below..AN  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee$B!G(Bs product to their customers with or
 *  without such third party$B!G(Bs private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications..AN  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein..AN 
 *.AN 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *.AN 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *.AN 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A.AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************
 */

/* 
 *   File: wfa_cs.c -- configuration and setup
 *   This file contains all implementation for the dut setup and control 
 *   functions, such as network interfaces, ip address and wireless specific
 *   setup with its supplicant.
 *
 *   The current implementation is to show how these functions
 *   should be defined in order to support the Agent Control/Test Manager 
 *   control commands. To simplify the current work and avoid any GPL licenses,
 *   the functions mostly invoke shell commands by calling linux system call,
 *   system("<commands>"). 
 *
 *   It depends on the differnt device and platform, vendors can choice their
 *   own ways to interact its system_with_logs, supplicants and process these commands
 *   such as using the native APIs.
 *
 *   Revision History:
 *        2006/03/10  -- initially created by qhu
 *        2006/06/01  -- BETA Release by qhu
 *        2006/06/13  -- 00.02 Release by qhu
 *        2006/06/30  -- 00.10 Release by qhu
 *        2006/07/10  -- 01.00 Release by qhu
 *        2006/09/01  -- 01.05 Release by qhu
 *        2006/10/26  -- 01.06 Released by qhu
 *                       replace hardcoded buf size with macro
 *        2006/12/02  -- bugs: 1. fixes incorrect order of getipconfig.sh
 *                                input parameters reported by p.schwann
 *                             2. will add a new network for wap_cli command
 *                                in case the network id 0 not present,
 *                                recommended by c.benson
 *                                the solution is to reimplement with calling
 *                                native C API
 *        2007/01/11  -- 01.10 released by qhu
 *        2007/02/15  -- WMM Extension Beta released by qhu, mkaroshi
 *        2007/03/18  -- add file close statements
 *        2007/03/21  -- rename the file to avoid the confusion.
 *        2007/03/30  -- 01.40 WPA2 and Official WMM Beta Release by qhu
 *        2007/04/20  -- 02.00 WPA2 and Official WMM Release by qhu
 *        2007/08/15 --  02.10 WMM-Power Save release by qhu
 *        2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *        2007/11/07 --  02.30 Voice HSO -- qhu
 *        2007/12/10 --  02.32 Add a function to upload test results.
 *        2008/01/03 --  02.34 Support the result upload command.
 *        2008/03/12 --  02.41 Bug #16, incorrect file descriptor used. Change 
 *                       the "tmpfile" to "tmpfd" and a few places. Make a macro
 *                       WFA_STAUT_IF in file "inc/wfa_cs.h" for WLAN interface
 *                       name in the function "wfaDeviceListIF()
 *                      
 *                       Not A Bug. Put back to the function from 
 *                       wfaSetEncryption1() to wfaSetEncryption() for 
 *                       supporting WEP. Porting could select which should be 
 *                       used according to WEP support or not.
 *        2012/01/20 --  04.02.01 -- v1.1 -- aprasad
 * 						 wfaStaP2pStartGrpFormation  -- Allow the device for association with interface address instead of P2P device ID
 *        2016/01/05 --  Unified Sigma solution --v1.0 -- aprasad                
 *        
 */ 
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <linux/types.h>
#include <linux/socket.h>
#include <poll.h>
#include <ctype.h>
#include <time.h>

#include "wfa_portall.h"
#include "wfa_debug.h"
#include "wfa_ver.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_ca.h"
#include "wfa_tlv.h"
#include "wfa_sock.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_rsp.h"
#include "wfa_utils.h"
#include "mrvl_gvars.h"
#include "mrvl_macros.h"
#include "mrvl_supplicant.h"
#include "mrvl_mwud.h"
#include "mrvl_miscs.h"
#include "mrvl_debug.h"
#ifdef WFA_WMM_PS_EXT
#include "wfa_wmmps.h"
#endif
int counter =0 ;

/*
 * agtCmdProcGetVersion(): response "ca_get_version" command to controller
 *  input:  cmd --- not used
 *          valLen -- not used
 *  output: parms -- a buffer to store the version info response.
 */
int agtCmdProcGetVersion(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
	ENTER( __func__ );
	dutCmdResponse_t *getverResp = &gGenericResp;
    getverResp->status = STATUS_COMPLETE;
    wSTRNCPY(getverResp->cmdru.version, M_VERSION, strlen(M_VERSION));
    wfaEncodeTLV(WFA_GET_VERSION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getverResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);	
	LEAVE( __func__ );
    return WFA_SUCCESS;
}

/*
 * wfaStaAssociate():
 *    The function is to force the station wireless I/F to re/associate 
 *    with the AP.
 */
int wfaStaAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *assoc = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *staAssocResp = &gGenericResp;
    char *ssid = assoc->cmdsu.ssid;
    char *bssid = assoc->cmdsu.assoc.bssid;
    int ret; 

	
    ENTER( __func__ );	
    memset(sta_saved_ssid, 0, 33);
    strncpy(sta_saved_ssid, ssid, (strlen(ssid) < 32) ? strlen(ssid): 32);

	if ( mrvl_dut_info->use_supplicant) {
        sprintf(gCmdStr, "./%s -i%s set rrm_used 1",
                mrvl_WS_info->supplicant_cli_bin,
                mrvl_WS_info->sta_ctrl_interface);
        system_with_log(gCmdStr);
		sprintf(gCmdStr, "./%s -i%s bssid %d %s",
				mrvl_WS_info->supplicant_cli_bin,
				mrvl_WS_info->sta_ctrl_interface,
				mrvl_WS_info->network_index,
				bssid);
	    system_with_log(gCmdStr);
		

		//if (mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH || runtime_test_data->eap_test) {

		if (mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH) {
		ret = launch_supplicant_file_instance(mrvl_dut_info->sta_interface,1);
			if (runtime_test_data->roam) {			
				sprintf(gCmdStr, "./%s -i %s DRIVER ROAM 1",
					mrvl_WS_info->supplicant_cli_bin,
					mrvl_WS_info->sta_ctrl_interface);
				system_with_log(gCmdStr);
			}	
		} else {
			ret = select_active_network(mrvl_WS_info->sta_ctrl_interface,mrvl_WS_info->network_index);
		}
		if (!strcasecmp(SIGMA_PROG_NAME,MRVL_TDLS_PROG)) {
			ret = enable_WS_tdls_capabilities(mrvl_WS_info->sta_ctrl_interface);
			ret = enable_mlan_tdls_capabilities(mrvl_dut_info->sta_interface);
		}
	}

	else {
		ret = sta_mlan_associate(mrvl_dut_info->sta_interface,ssid);
	}
		
	if ( ret == FALSE ) {
	    staAssocResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + 4;
		return WFA_FAILURE; 
	}
	
	/** DHCP Client */
	if (runtime_test_data->dhcp && check_wlan_connectivity(mrvl_dut_info->sta_interface)  == TRUE) {
		invoke_dhcp_client(sta_interface,1);
	}
	
	/** Special Handling for VHT program */
	if (!MWIFIEX) {
		if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_VHT_PROG) ) {
			ret = set_mlan_txrate(mrvl_dut_info->sta_interface,saved_mcs_fixed_rate,saved_txsp_stream);	
		}
		ret = enable_mlan_reassoc_ctrl(mrvl_dut_info->sta_interface);
	}
	if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_HE_PROG) ) 
		{
			if (!strcasecmp(ssid,"HE-5.25.1_24G"))
				{DPRINT_INFO(WFA_OUT,"HE-5.25 in 24G");
			  sprintf(gCmdStr, "%s/%s %s txratecfg 3 7 2 0x2220", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
        		  system_with_log(gCmdStr);
				}
			if (!strcasecmp(ssid,"HE-5.25.1"))
				{DPRINT_INFO(WFA_OUT,"HE-5.25 in 5G");
			   sprintf(gCmdStr, "%s/%s %s txratecfg 3 7 2 0x2220", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
        		   system_with_log(gCmdStr);
				}
			if (!strcasecmp(ssid,"HE-5.27.1_24G"))
				{DPRINT_INFO(WFA_OUT,"HE-5.27 in 24G");
			  sprintf(gCmdStr, "%s/%s %s txratecfg 3 7 2 0x2020", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
        		  system_with_log(gCmdStr);
				}
			if (!strcasecmp(ssid,"HE-5.27.1"))
				{DPRINT_INFO(WFA_OUT,"HE-5.27 in 5G");
			   sprintf(gCmdStr, "%s/%s %s txratecfg 3 7 2 0x2020", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
			   system_with_log(gCmdStr);
				}
			if (!strcasecmp(ssid,"HE-5.36.1_24G")) {
			 		 if (counter ==0){
					 	 DPRINT_INFO(WFA_OUT,"HE-5.36 in 24G 1st Assoc ");
						 sprintf(gCmdStr, "%s/%s %s txratecfg 3 9 1 0x2020", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
        		 			 system_with_log(gCmdStr);
					        counter ++;
				        } else if (counter ==1) {
				        	DPRINT_INFO(WFA_OUT,"HE-5.36 in 24G 2nd  assoc"); 
					  	sprintf(gCmdStr, "%s/%s %s txratecfg 3 9 2 0x2020", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
        				  	system_with_log(gCmdStr);
					       counter = 0;
					}
				}
			if (!strcasecmp(ssid,"HE-5.36.1")) {
					 if (counter ==0){
						DPRINT_INFO(WFA_OUT,"HE-5.36 in 5G 1st Assoc ");
						sprintf(gCmdStr, "%s/%s %s txratecfg 3 9 1 0x2228", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
						system_with_log(gCmdStr);
						counter ++;
					} else if (counter ==1) {
						DPRINT_INFO(WFA_OUT,"HE-5.36 in 5G 2nd  assoc"); 
						sprintf(gCmdStr, "%s/%s %s txratecfg 3 9 2 0x2228", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
						system_with_log(gCmdStr);
						counter = 0;
						}
				}

		}
    staAssocResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return WFA_SUCCESS; 
}

/*
 * wfaStaReAssociate():
 *    The function is to force the station wireless I/F to re/associate 
 *    with the AP.
 */
int wfaStaReAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *assoc = (dutCommand_t *)caCmdBuf;
	caStaAssociate_t *reassoc = (caStaAssociate_t *) &assoc->cmdsu.assoc;
	caStaSetSecurity_t *sec = &assoc->cmdsu.setsec; 
	dutCmdResponse_t *staAssocResp = &gGenericResp;
	int ret,cnt=0; 
	
	ENTER( __func__ );
	if ( mrvl_dut_info->use_supplicant ) {
		ret = enable_supplicant_reassoc_ctrl(mrvl_WS_info->sta_ctrl_interface,mrvl_WS_info->network_index,reassoc->bssid, reassoc->channel);
	} 

	else {
			sprintf(gCmdStr,"killall wpa_supplicant");
			system_with_log(gCmdStr);
			
			if (sec->SAE_FLAG == 1)
				{printf("\n\r The reassoc API is called in SAE\n\r");
				sprintf(gCmdStr, "%s/%s %s associate \"%s Wi-Fi-5.2.1\"",APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface,reassoc->bssid);
				system_with_log(gCmdStr);
				ret = enable_mlan_reassoc_ctrl(mrvl_dut_info->sta_interface);
				}
			else 
			ret = enable_mlan_reassoc_ctrl(mrvl_dut_info->sta_interface);
		}
	
	while (cnt<10) {
		sleep(2);
		if ( check_wlan_connectivity(mrvl_dut_info->sta_interface)  == TRUE )
			break;
		cnt++;
	}

	staAssocResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return WFA_SUCCESS; 
}

/*
 * wfaStaIsConnected():
 *    The function is to check whether the station's wireless I/F has 
 *    already connected to an AP.
 */
int wfaStaIsConnected(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *connStat = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *staConnectResp = &gGenericResp;
	int ret; 
	
	ENTER( __func__ );
	ret = check_wlan_connectivity(mrvl_dut_info->sta_interface);	
	if ( ret == FALSE ) {
		/** Give one more chance for association */ 
		if ( mrvl_dut_info->use_supplicant ) { 
			enable_supplicant_association(mrvl_WS_info->sta_ctrl_interface,sta_saved_ssid);
		} else {
			enable_mlan_association(mrvl_dut_info->sta_interface,sta_saved_ssid);
		}
		ret = check_wlan_connectivity(mrvl_dut_info->sta_interface);
		if ( ret == TRUE ) 
			staConnectResp->cmdru.connected = 1;
		else 
			staConnectResp->cmdru.connected = 0;			
	} else {
		staConnectResp->cmdru.connected = 1;
	}
	LEAVE( __func__ );
	staConnectResp->status = STATUS_COMPLETE;   
	wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)staConnectResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
    return WFA_SUCCESS;
}

/*
 * wfaStaGetIpConfig():
 * This function is to retriev the ip info including
 *     1. dhcp enable
 *     2. ip address
 *     3. mask 
 *     4. primary-dns
 *     5. secondary-dns
 *
 *     The current implementation is to use a script to find these information
 *     and store them in a file. 
 */
int wfaStaGetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *getIpConf = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *ipconfigResp = &gGenericResp; 
    caStaGetIpConfigResp_t *ifinfo = &ipconfigResp->cmdru.getIfconfig;
	int ret; 	
	ENTER( __func__ );

	ret = fetch_mlan_ip_connection_info(ifinfo,mrvl_dut_info->sta_interface,getIpConf->cmdsu.ipconfig.type);
    if(ret == FALSE) {
       ipconfigResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);   
       *respLen = WFA_TLV_HDR_LEN + 4;
	   LEAVE( __func__ );
       return FALSE; 
    }
	if ( getIpConf->cmdsu.ipconfig.type != 2) {
		DPRINT_INFO(WFA_OUT, "%i %i %s %s %s %s %i\n", ipconfigResp->status, 
			    ifinfo->isDhcp, ifinfo->ipaddr, ifinfo->mask, 
			    ifinfo->dns[0], ifinfo->dns[1], *respLen);
	}

    ipconfigResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)ipconfigResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);    
	LEAVE( __func__ );	
    return WFA_SUCCESS;
}

/*
 * wfaStaSetIpConfig():
 *   The function is to set the ip configuration to a wireless I/F.
 *   1. IP address
 *   2. Mac address
 *   3. default gateway
 *   4. dns nameserver (pri and sec).  
 */
int wfaStaSetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCommand_t *setIpConf = (dutCommand_t *)caCmdBuf;
	caStaSetIpConfig_t *ipconfig = &setIpConf->cmdsu.ipconfig;
	dutCmdResponse_t *staSetIpResp = &gGenericResp;
	int ret; 	
	ENTER( __func__ );	
	
	if ( ipconfig->type != 2) 
		ipconfig->type = 1;
		
	if ( ipconfig->isDhcp ) {
		if (ipconfig->type == 1 && check_wlan_connectivity(mrvl_dut_info->sta_interface) == TRUE) { 
			/** IPv4 */		
			invoke_dhcp_client(mrvl_dut_info->sta_interface,1); 
		} else if (ipconfig->type == 2) { 
			/** IPv6 */			
			invoke_dhcp_client(mrvl_dut_info->sta_interface,2);	
		} else {
			runtime_test_data->dhcp = 1;
		}
	} else {
		ret = set_static_ip_config(mrvl_dut_info->sta_interface,ipconfig);  					
	}
		
	staSetIpResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
	return WFA_SUCCESS;
}

/*
 * wfaStaVerifyIpConnection():
 * The function is to verify if the station has IP connection with an AP by
 * send ICMP/pings to the AP.
 */ 
int wfaStaVerifyIpConnection(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCommand_t *verip = (dutCommand_t *)caCmdBuf;
	dutCmdResponse_t *verifyIpResp = &gGenericResp;
	
	int ret; 	
	ENTER( __func__ );	
	
#ifndef WFA_PING_UDP_ECHO_ONLY	
    /** Set timeout value in case not set */
	if(verip->cmdsu.verifyIp.timeout <= 0)
		verip->cmdsu.verifyIp.timeout = 10;
   
	ret = check_ping_connectivity (verip->cmdsu.verifyIp.dipaddr,verip->cmdsu.verifyIp.timeout);
    if ( ret == FALSE ) {
		verifyIpResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + 4;
		LEAVE( __func__ );
		return WFA_FAILURE;
	} else {
		verifyIpResp->cmdru.connected = ret;
	}

#else
   int btSockfd;
   struct pollfd fds[2];
   int timeout = 2000;
   char anyBuf[64];
   struct sockaddr_in toAddr;
   int done = 1, cnt = 0, ret, nbytes;

   verifyIpResp->status = STATUS_COMPLETE;
   verifyIpResp->cmdru.connected = 0;
   btSockfd = wfaCreateUDPSock("127.0.0.1", WFA_UDP_ECHO_PORT);

   if(btSockfd == -1)
   {
		verifyIpResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + 4;
		return WFA_FAILURE;;
   }

   toAddr.sin_family = AF_INET;
   toAddr.sin_addr.s_addr = inet_addr(verip->cmdsu.verifyIp.dipaddr);
   toAddr.sin_port = htons(WFA_UDP_ECHO_PORT);

   while(done)
   {
       wfaTrafficSendTo(btSockfd, (char *)anyBuf, 64, (struct sockaddr *)&toAddr);
       cnt++;

       fds[0].fd = btSockfd;
       fds[0].events = POLLIN | POLLOUT; 

       ret = poll(fds, 1, timeout);
       switch(ret)
       {
           case 0:
             /* it is time out, count a packet lost*/
           break;
           case -1:
             /* it is an error */
           default:
           {
              switch(fds[0].revents)
              {
                  case POLLIN:
                  case POLLPRI:
                  case POLLOUT:
                  nbytes = wfaTrafficRecv(btSockfd, (char *)anyBuf, (struct sockaddr *)&toAddr);
                  if(nbytes != 0)
                      verifyIpResp->cmdru.connected = 1;
                      done = 0;
                  break;
                  default:
                  /* errors but not care */
                   ;
              } 
           }
       } 
       if(cnt == 3)
       {
          done = 0;
       }
   } 
#endif
   wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)verifyIpResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   LEAVE( __func__ );
   return WFA_SUCCESS;
}

/*
 * wfaStaGetMacAddress()
 *    This function is to retrieve the MAC address of a wireless I/F.
 */
int wfaStaGetMacAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *getMac = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *getmacResp = &gGenericResp;
	int ret; 	
	
	ENTER( __func__ );	
	ret = fetch_mac_address(mrvl_dut_info->sta_interface,getmacResp->cmdru.mac);
	if ( ret == FALSE ) {
		getmacResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)getmacResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + 4;
		LEAVE( __func__ );
		return WFA_FAILURE;
	}
	
    getmacResp->status = STATUS_COMPLETE; 
    wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getmacResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
	LEAVE( __func__ );
    return WFA_SUCCESS;
}

/*
 * wfaStaGetStats():
 * The function is to retrieve the statistics of the I/F's layer 2 txFrames, 
 * rxFrames, txMulticast, rxMulticast, fcsErrors/crc, and txRetries.
 * Currently there is not definition how to use these info. 
 */
int wfaStaGetStats(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *statsResp = &gGenericResp;
   ENTER( __func__ );	
   /** TODO */
   
   statsResp->status = STATUS_ERROR;
   wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)statsResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   LEAVE( __func__ );
   return WFA_SUCCESS;
}

/*
 * wfaSetEncryption():
 *   The function is to set the wireless interface with WEP or none.
 *
 *   Since WEP is optional test, current function is only used for 
 *   resetting the Security to NONE/Plaintext (OPEN). To test WEP, 
 *   this function should be replaced by the next one (wfaSetEncryption1())
 *
 *   Input parameters: 
 *     1. I/F
 *     2. ssid
 *     3. encpType - wep or none
 *     Optional:
 *     4. key1
 *     5. key2
 *     6. key3
 *     7. key4
 *     8. activeKey Index
 */

int wfaSetEncryption(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
    dutCmdResponse_t *setEncrypResp = &gGenericResp;   
    int activeKeyIdx = setEncryp->activeKeyIdx;
    char *ssid = (char *)setEncryp->ssid;
    int ret;
	
	FILE *fp=NULL;
	ENTER( __func__ );

    /** 0=NONE, 1=WEP */    
    if (setEncryp->encpType) {
        if (mrvl_dut_info->use_supplicant) {
			if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {			
				fp = fopen(SUPPLICANT_CONF,"w");
				if ( fp == NULL ) {
					DPRINT_ERR(WFA_ERR,"File Opening error");
					setEncrypResp->status = STATUS_ERROR;
					wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
					*respLen = WFA_TLV_HDR_LEN + 4;
					return WFA_FAILURE;
				}
				fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
				fprintf(fp,"ap_scan=1\n");
				fprintf(fp,"network={\n");
				fprintf(fp,"\tssid=\"%s\"\n",ssid);
				fprintf(fp,"\tkey_mgmt=NONE\n");	
				if (setEncryp->keys[0][0] != '\0') {
					fprintf(fp,"\twep_key0=%s\n",setEncryp->keys[0]);
				}
				if (setEncryp->keys[1][0] != '\0') {
					fprintf(fp,"\twep_key1=%s\n",setEncryp->keys[1]);
				}
				if (setEncryp->keys[2][0] != '\0') {
					fprintf(fp,"\twep_key2=%s\n",setEncryp->keys[2]);
				}
				if (setEncryp->keys[3][0] != '\0') {
					fprintf(fp,"\twep_key3=%s\n",setEncryp->keys[3]);
				}
				fprintf(fp,"\twep_tx_keyidx=%d\n",activeKeyIdx);
				fprintf(fp,"}\n");
				fclose(fp);
				console_dump_file(SUPPLICANT_CONF);
			} else { 
				ret = set_wpacli_wep_configuration(setEncryp->keys[0],setEncryp->keys[1],setEncryp->keys[2],setEncryp->keys[3],activeKeyIdx);
			}
		} else {
			ret = set_mlan_wep_configuration(setEncryp->keys[0],setEncryp->keys[1],setEncryp->keys[2],setEncryp->keys[3],activeKeyIdx);	
		}
    } else {
        if (mrvl_dut_info->use_supplicant) {
			if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {	
				fp = fopen(SUPPLICANT_CONF,"w");
				if ( fp == NULL ) {
					DPRINT_ERR(WFA_ERR,"File Opening error");
					setEncrypResp->status = STATUS_ERROR;
					wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
					*respLen = WFA_TLV_HDR_LEN + 4;
					return WFA_FAILURE;
				}
				fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
				fprintf(fp,"ap_scan=1\n");
				fprintf(fp,"network={\n");
				fprintf(fp,"\tssid=\"%s\"\n",ssid);		
				fprintf(fp,"\tkey_mgmt=NONE\n");
				fprintf(fp,"}\n");
				fclose(fp);	
				console_dump_file(SUPPLICANT_CONF);
			} else {
				mrvl_WS_info->network_index = get_supplicant_network_index(mrvl_WS_info->sta_ctrl_interface);
				ret= set_wpacli_open_configuration(mrvl_WS_info->sta_ctrl_interface,mrvl_WS_info->network_index,ssid);
			}
		} else {
			ret = set_mlan_open_configuration(mrvl_WS_info->sta_ctrl_interface); 
		}
    }
    setEncrypResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}

/*
 * wfaStaSetEapTLS():
 *   This is to set
 *   1. ssid
 *   2. encrypType - tkip or aes-ccmp
 *   3. keyManagementType - wpa or wpa2
 *   4. trustedRootCA
 *   5. clientCertificate
 */
int wfaStaSetEapTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
    dutCmdResponse_t *setEapTlsResp = &gGenericResp;

    char *ssid = setTLS->ssid;
    char *encrptype = setTLS->encrptype;
    char *keyMgmtType = setTLS->keyMgmtType;
    char *trustedRootCA = setTLS->trustedRootCA;
    char *clientCertificate = setTLS->clientCertificate;
    char *identity = NULL;
	
	FILE *fp=NULL;
	ENTER( __func__ );
	
	if (mrvl_dut_info->use_supplicant) {
		if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {	
			fp = fopen(SUPPLICANT_CONF,"w");
			if ( fp == NULL ) {
				setEapTlsResp->status = STATUS_ERROR;
				wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
				*respLen = WFA_TLV_HDR_LEN + 4;
				return WFA_FAILURE;
			}
			fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
			fprintf(fp,"ap_scan=1\n");
			fprintf(fp,"update_config=1\n");
			fprintf(fp,"network={\n");
			fprintf(fp,"\tssid=\"%s\"\n",ssid);
			
			if (!strcasecmp(SIGMA_PROG_NAME,MRVL_PMF_PROG)) {
				if ( !strcasecmp(setTLS->keyMgmtType,WPA2_SHA256) ){
					fprintf(fp,"\tkey_mgmt=WPA-EAP-SHA256\n");
				} else if ( !strcasecmp(setTLS->keyMgmtType,WPA2_EAP)){
					fprintf(fp,"\tkey_mgmt=WPA-EAP\n");
				} else if ( !strcasecmp(setTLS->keyMgmtType,WPA2_FT)){
					fprintf(fp,"\tkey_mgmt=FT-EAP\n");
				} else if ( !strcasecmp(setTLS->keyMgmtType,WPA2)){
					fprintf(fp,"\tkey_mgmt=WPA-EAP\n");
				} else {
					/** Do Nothing */
				}
				switch (setTLS->pmf){
					case WFA_F_REQUIRED:
					fprintf(fp,"\tieee80211w=0\n");
					break;
					case WFA_REQUIRED:
					fprintf(fp,"\tieee80211w=2\n");
					break;						
					case WFA_ENABLED:
					fprintf(fp,"\tieee80211w=1\n");
					break;
					case WFA_F_DISABLED:
					fprintf(fp,"\tieee80211w=0\n");
					break;
					default:
					case WFA_DISABLED:
					fprintf(fp,"\tieee80211w=0\n");
					break;
				}
			} else {
            if ( !strcasecmp(setTLS->keyMgmtType,WPA2_SHA256) ){
                fprintf(fp,"\tkey_mgmt=WPA-EAP-SHA256\n");
            } else if ( !strcasecmp(setTLS->keyMgmtType,WPA2_EAP)){
				fprintf(fp,"\tkey_mgmt=WPA-EAP\n");
            } else if ( !strcasecmp(setTLS->keyMgmtType,WPA2_FT)){
                fprintf(fp,"\tkey_mgmt=FT-EAP\n");
            } else if ( !strcasecmp(setTLS->keyMgmtType,WPA2)){
                fprintf(fp,"\tkey_mgmt=WPA-EAP\n");
            } else {
			/** Do Nothing */
            }
			}
			configure_supplicant_security_mode (fp,encrptype,keyMgmtType,ssid);
			fprintf(fp,"\teap=TLS\n");
			if((identity = getenv("EAPTLS_IDENTITY")) == NULL) {
				fprintf(fp,"\tidentity=\"wifi\"\n");
			} else {
				fprintf(fp,"\tidentity=\"%s\"\n",identity);
			}
			fprintf(fp,"\tca_cert=\"%s\"\n",update_client_certificate_name(trustedRootCA,"pem"));
			fprintf(fp,"\tclient_cert=\"%s\"\n",update_client_certificate_name(clientCertificate,"pem"));	
			fprintf(fp,"\tprivate_key=\"%s\"\n",update_client_certificate_name(clientCertificate,"pem"));
			fprintf(fp,"\tprivate_key_passwd=\"wifi\"\n");
			fprintf(fp,"}\n");	
			fclose(fp);
			console_dump_file(SUPPLICANT_CONF);
		} else {
			/** TODO: Yet to implement using WPA CLI approach */
			return WFA_FAILURE;
		}
	} else {
		DPRINT_ERR(WFA_ERR,"EapTLS Configuration not supported using Embedded supplicant\n");
		return WFA_FAILURE;
	}
	runtime_test_data->eap_test =1;
    setEapTlsResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return WFA_SUCCESS;
}

/*
 * The function is to set 
 *   1. ssid
 *   2. passPhrase
 *   3. keyMangementType - wpa/wpa2
 *   4. encrypType - tkip or aes-ccmp
 */
int wfaStaSetPSK(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
    dutCmdResponse_t *setPskResp = &gGenericResp;

    char *ssid = setPSK->ssid;
    char *passphrase = (char *)setPSK->passphrase;
    char* encrptype = setPSK->encrptype;
  	char* keyMgmtType = setPSK->keyMgmtType;
	int ret; 
		
 	FILE *fp=NULL;
	ENTER( __func__ );
	
	if (mrvl_dut_info->use_supplicant) {
		if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {	
			fp = fopen(SUPPLICANT_CONF,"w");
			if ( fp == NULL ) {
				setPskResp->status = STATUS_ERROR;
				wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
				*respLen = WFA_TLV_HDR_LEN + 4;
				return WFA_FAILURE;
			}
			fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
			fprintf(fp,"ap_scan=1\n");			
			fprintf(fp,"network={\n");
			fprintf(fp,"\tssid=\"%s\"\n",ssid);
			
			if (!strcasecmp(SIGMA_PROG_NAME,MRVL_PMF_PROG)){	
				if (!strcasecmp(setPSK->keyMgmtType,WPA2_SHA256)){
					fprintf(fp,"\tkey_mgmt=WPA-PSK-SHA256\n");
				} else if (!strcasecmp(setPSK->keyMgmtType,WPA2_PSK)){
					fprintf(fp,"\tkey_mgmt=WPA-PSK\n");
				} else if (!strcasecmp(setPSK->keyMgmtType,WPA2_FT)){
					fprintf(fp,"\tkey_mgmt=FT-PSK\n");
				} else if (!strcasecmp(setPSK->keyMgmtType,WPA2) && !setPSK->micAlg && setPSK->pmf == WFA_DISABLED){
					fprintf(fp,"\tkey_mgmt=WPA-PSK\n");
				} else if (!strcasecmp(setPSK->keyMgmtType,WPA2) && !setPSK->micAlg && setPSK->pmf != WFA_DISABLED){
					fprintf(fp,"\tkey_mgmt=WPA-PSK WPA-PSK-SHA256\n");
				} else if (!strcasecmp(setPSK->keyMgmtType,WPA2) && setPSK->micAlg == 256 && setPSK->pmf == WFA_DISABLED){
					fprintf(fp,"\tkey_mgmt=WPA-PSK-SHA256\n");
				} else {
					/** Do nothing */	
				}
				switch (setPSK->pmf) {
					case WFA_F_REQUIRED:
					fprintf(fp,"\tieee80211w=0\n");
					break;
					case WFA_REQUIRED:
					fprintf(fp,"\tieee80211w=2\n");
					break;
					case WFA_ENABLED: 
					fprintf(fp,"\tieee80211w=1\n");
					break;
					case WFA_F_DISABLED:
					fprintf(fp,"\tieee80211w=0\n");
					break;
					default:
					case WFA_DISABLED:
					fprintf(fp,"\tieee80211w=0\n");
					break;
				}				
			} else {
				fprintf(fp,"\tkey_mgmt=WPA-PSK\n");
				configure_supplicant_security_mode (fp,encrptype,keyMgmtType,ssid);	
			}
			fprintf(fp,"\tpsk=\"%s\"\n",passphrase);		
			fprintf(fp,"}\n");
			fclose(fp);
			console_dump_file(SUPPLICANT_CONF);
		} else {
			mrvl_WS_info->network_index = get_supplicant_network_index(mrvl_WS_info->sta_ctrl_interface);
			if (setPSK->prefer) {
				ret = assign_network_priority(mrvl_WS_info->sta_ctrl_interface,mrvl_WS_info->network_index);
			}
			ret = configure_supplicant_cli(mrvl_WS_info->network_index, SEC_TYPE_PSK, encrptype,keyMgmtType,ssid,passphrase);	
		}
	} else {
		if (!MWIFIEX) {
			ret = set_mlan_passphrase(mrvl_dut_info->sta_interface,ssid,passphrase);
			if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_PMF_PROG) ) {
				ret = set_mlan_pmf_configuration(mrvl_dut_info->sta_interface,setPSK->pmf);
			}
		}
	}
    setPskResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE; 
}

/*
 * wfaStaGetInfo(): 
 * Get vendor specific information in name/value pair by a wireless I/F.
 */
int wfaStaGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf;
	char version[128] = {0};	
	int ret; 

	ENTER( __func__ );   
	if (!MWIFIEX) {
		ret = get_mlan_driver_version(mrvl_dut_info->sta_interface,version);		
		if ( ret == FALSE ) {
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
			*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
			LEAVE( __func__ );
			return WFA_FAILURE;
		}
		sprintf(infoResp.cmdru.info, "interface,%s,vendor,Marvell,cardtype,%s",mrvl_dut_info->sta_interface,version);
	} else {
		sprintf(infoResp.cmdru.info, "interface,%s,vendor,Marvell,cardtype,%s",mrvl_dut_info->sta_interface,"MarvellSoC");
	}
	
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
	return TRUE;
}

/*
 * wfaStaSetEapTTLS():
 *   This is to set
 *   1. ssid
 *   2. username
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyManagementType - wpa or wpa2
 *   6. trustedRootCA
 */
int wfaStaSetEapTTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapTTLS_t *setTTLS = (caStaSetEapTTLS_t *)caCmdBuf;
    dutCmdResponse_t *setEapTtlsResp = &gGenericResp;
    char *ifname = setTTLS->intf;
    char *ssid = setTTLS->ssid;
    char *encrptype = setTTLS->encrptype;
    char *keyMgmtType = setTTLS->keyMgmtType;
    char *trustedRootCA = setTTLS->trustedRootCA;
    char *clientCertificate = setTTLS->clientCertificate;
    char *username = setTTLS->username;
    char *passwd = setTTLS->passwd;
	int ret;

	FILE *fp=NULL;
	ENTER( __func__ );
	
	if (mrvl_dut_info->use_supplicant) {
		if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {
			fp = fopen(SUPPLICANT_CONF,"w");
			if ( fp == NULL ) {
			    setEapTtlsResp->status = STATUS_ERROR;
				wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);
				*respLen = WFA_TLV_HDR_LEN + 4;
				return WFA_FAILURE;
			}
			fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
			fprintf(fp,"ap_scan=1\n");			
			fprintf(fp,"network={\n");
			fprintf(fp,"\tssid=\"%s\"\n",ssid);
        if ( !strcasecmp(setTTLS->keyMgmtType,WPA2_SHA256) ){
            fprintf(fp,"\tkey_mgmt=WPA-EAP-SHA256\n");
        } else if ( !strcasecmp(setTTLS->keyMgmtType,WPA2_EAP)){
			fprintf(fp,"\tkey_mgmt=WPA-EAP\n");
        } else if ( !strcasecmp(setTTLS->keyMgmtType,WPA2_FT)){
            fprintf(fp,"\tkey_mgmt=FT-EAP\n");
        } else if ( !strcasecmp(setTTLS->keyMgmtType,WPA2)){
            fprintf(fp,"\tkey_mgmt=WPA-EAP\n");
        } else {
            fprintf(fp,"\tkey_mgmt=WPA-EAP\n");
        }
			configure_supplicant_security_mode (fp,encrptype,keyMgmtType,ssid);
			fprintf(fp,"\teap=TTLS\n");
			fprintf(fp,"\tidentity=\"%s\"\n",username);
			fprintf(fp,"\tca_cert=\"%s\"\n",update_client_certificate_name(trustedRootCA,"pem"));
			fprintf(fp,"\tpassword=\"%s\"\n",passwd);
			fprintf(fp,"\tphase2=\"auth=MSCHAPV2\"\n");
			fprintf(fp,"}\n");
			fclose(fp);
			console_dump_file(SUPPLICANT_CONF);
			} 
		else {
			mrvl_WS_info->network_index = get_supplicant_network_index(mrvl_WS_info->sta_ctrl_interface);
			if (setTTLS->prefer) {
				ret = assign_network_priority(mrvl_WS_info->sta_ctrl_interface,mrvl_WS_info->network_index);
			}
			configure_eapttls_cli(setTTLS,mrvl_WS_info->network_index);										
		}
	} else {
		/** TODO */
		return WFA_FAILURE;
	}	
	runtime_test_data->eap_test =1;
    setEapTtlsResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}

/*
 * wfaStaSetEapSIM():
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyMangementType - wpa or wpa2
 */
int wfaStaSetEapSIM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapSIM_t *setSIM = (caStaSetEapSIM_t *)caCmdBuf;
    dutCmdResponse_t *setEapSimResp = &gGenericResp;
    char *ifname = setSIM->intf;
    char *ssid = setSIM->ssid;
    char *encrptype = setSIM->encrptype;
    char *keyMgmtType = setSIM->keyMgmtType;
    char *username = setSIM->username;
    char *passwd = setSIM->passwd;

	FILE *fp=NULL;
	ENTER( __func__ );
	
    if (mrvl_dut_info->use_supplicant) {
		if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {	
			fp = fopen(SUPPLICANT_CONF,"w");
			if ( fp == NULL ) {
				setEapSimResp->status = STATUS_ERROR;
				wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);
				*respLen = WFA_TLV_HDR_LEN + 4;
				return WFA_FAILURE;
			}
			fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
			fprintf(fp,"ap_scan=1\n");
			fprintf(fp,"network={\n");
			fprintf(fp,"\tssid=\"%s\"\n",ssid);			
			fprintf(fp,"\tkey_mgmt=WPA-EAP\n");
			configure_supplicant_security_mode (fp,encrptype,keyMgmtType,ssid);
			fprintf(fp,"\teap=SIM\n");
			fprintf(fp,"\tidentity=\"%s\"\n",username);
			fprintf(fp,"\tpassword=\"%s\"\n",passwd);
			fprintf(fp,"}\n");
			fclose(fp);
			console_dump_file(SUPPLICANT_CONF);
		} else {
			/** TODO */
			return WFA_FAILURE;
		}
	} else {
		/** TODO */
		return WFA_FAILURE;
	}
    runtime_test_data->eap_test =1;
    setEapSimResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}

/*
 * wfaStaSetPEAP()
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encryType - tkip or aes-ccmp
 *   5. keyMgmtType - wpa or wpa2
 *   6. trustedRootCA
 *   7. innerEAP
 *   8. peapVersion
 */

/* 
 *  This funtion is not ported to android. Need clear directions on use of this function...
 */
int wfaStaSetPEAP(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
    dutCmdResponse_t *setPeapResp = &gGenericResp;
    char *ifname = setPEAP->intf;
    char *ssid = setPEAP->ssid;
    char *encrptype = setPEAP->encrptype;
	char *keyMgmtType = setPEAP->keyMgmtType;
    char *trustedRootCA = setPEAP->trustedRootCA;
    char *username = setPEAP->username;
    char *passwd = setPEAP->passwd;
    char *innerEAP = setPEAP->innerEAP;
    int peapVersion = setPEAP->peapVersion;

	FILE *fp=NULL;
	ENTER( __func__ );
	
	if (mrvl_dut_info->use_supplicant) {
		if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {
			fp = fopen(SUPPLICANT_CONF,"w");
			if ( fp == NULL ) {
				setPeapResp->status = STATUS_ERROR;
				wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
				*respLen = WFA_TLV_HDR_LEN + 4;
				return WFA_FAILURE;
			}
			fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
			fprintf(fp,"ap_scan=1\n");
			fprintf(fp,"network={\n");
			fprintf(fp,"\tssid=\"%s\"\n",ssid);				
			fprintf(fp,"\tkey_mgmt=WPA-EAP\n");		
			configure_supplicant_security_mode (fp,encrptype,keyMgmtType,ssid);
			fprintf(fp,"\teap=PEAP\n");
			fprintf(fp,"\tidentity=\"%s\"\n",username);
			fprintf(fp,"\tpassword=\"%s\"\n",passwd);
			fprintf(fp,"\tca_cert=\"%s.pem\"\n",trustedRootCA);
			fprintf(fp,"\tphase1=\"peapver=%i\"\n",peapVersion);
			fprintf(fp,"\tphase2=\"auth=MSCHAPV2\"\n");
			fprintf(fp,"}\n");
			fclose(fp);
			console_dump_file(SUPPLICANT_CONF);
		} else {
			/** TODO */
			return WFA_FAILURE;
		}
	} else {
		/** TODO */
		return WFA_FAILURE;
	}
	runtime_test_data->eap_test =1;
    setPeapResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}

/*
 * wfaStaSetUAPSD()
 *    This is to set
 *    1. acBE
 *    2. acBK
 *    3. acVI
 *    4. acVO
 */

/* 
 *  This funtion is not ported to android. Need clear directions on use of this function...
 */
int wfaStaSetUAPSD(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetUAPSD_t *setUAPSD = (caStaSetUAPSD_t *)caCmdBuf;
	dutCmdResponse_t *setUAPSDResp = &gGenericResp;
	ENTER( __func__ );  
	int qoscfg=0;
	int ret;	
 		
	BYTE acBE=1;
	BYTE acBK=1;
	BYTE acVO=1;
	BYTE acVI=1;
#ifndef WFA_WMM_AC
	if(setUAPSD->acBE != 1) acBE=setUAPSD->acBE = 0;
	if(setUAPSD->acBK != 1) acBK=setUAPSD->acBK = 0;
	if(setUAPSD->acVO != 1) acVO=setUAPSD->acVO = 0;
	if(setUAPSD->acVI != 1) acVI=setUAPSD->acVI = 0;
#else
	acBE=setUAPSD->acBE;
	acBK=setUAPSD->acBK;
	acVO=setUAPSD->acVO;
	acVI=setUAPSD->acVI;
#endif

	if (acBE) qoscfg += 8;
	if (acBK) qoscfg += 4;
	if (acVI) qoscfg += 2;
	if (acVO) qoscfg += 1;
	ret = set_mlan_uapsd(mrvl_dut_info->sta_interface,qoscfg);
	if ( ret == FALSE ) {
		setUAPSDResp->status = STATUS_ERROR;
		LEAVE( __func__ );
		return WFA_FAILURE;
	}	
	setUAPSDResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_UAPSD_RESP_TLV, 4, (BYTE *)setUAPSDResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;	
	LEAVE( __func__ );
	return WFA_SUCCESS;
}

int wfaDeviceGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCommand_t *dutCmd = (dutCommand_t *)caCmdBuf;
	caDevInfo_t *devInfo = &dutCmd->cmdsu.dev;
	dutCmdResponse_t *infoResp = &gGenericResp;
	ENTER( __func__ );    
	int ret; 
	
	caDeviceGetInfoResp_t dinfo = { "Marvell", "MarvellSoC", "fw_version_unknown", M_VERSION };
	strcpy(dinfo.model, mrvl_dut_info->model);
	ret = get_mlan_driver_version(mrvl_dut_info->sta_interface, dinfo.version);		
	if ( ret == FALSE ) {
		infoResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
		LEAVE( __func__ );
		return WFA_FAILURE;
	}
	memcpy(&infoResp->cmdru.devInfo, &dinfo, sizeof(caDeviceGetInfoResp_t));
   
   	strcpy(dutCmd->intf,mrvl_dut_info->sta_interface);
	strcpy(sta_interface,mrvl_dut_info->sta_interface);
	 
	infoResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
	LEAVE( __func__ );
	return WFA_SUCCESS;
}

int wfaDeviceListIF(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t *infoResp = &gGenericResp;
	dutCommand_t *ifList = (dutCommand_t *)caCmdBuf;
	caDeviceListIFResp_t *ifListResp = &infoResp->cmdru.ifList;
	ENTER( __func__ );   
	char *ifname;

	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_P2P_PROG) || !strcasecmp(SIGMA_PROG_NAME,MRVL_WFD_PROG)) {
		ifname = mrvl_dut_info->p2p_interface;	
	} else {
		ifname = mrvl_dut_info->sta_interface;
	}

    switch(ifList->cmdsu.iftype)
    {
		case IF_80211:
		infoResp->status = STATUS_COMPLETE;
		ifListResp->iftype = IF_80211; 
		strcpy(ifListResp->ifs[0], ifname);
		strcpy(ifListResp->ifs[1], "NULL");
		strcpy(ifListResp->ifs[2], "NULL");
		break;
		case IF_ETH:
		infoResp->status = STATUS_COMPLETE;
		ifListResp->iftype = IF_ETH; 
		strcpy(ifListResp->ifs[0], "eth0");
		strcpy(ifListResp->ifs[1], "NULL");
		strcpy(ifListResp->ifs[2], "NULL");
		break;
		default:
		{
			infoResp->status = STATUS_ERROR;
			wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, 4, (BYTE *)infoResp, respBuf);   
			*respLen = WFA_TLV_HDR_LEN + 4;
			LEAVE( __func__ );
			return WFA_SUCCESS; 
		}
    }   
	wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
	LEAVE( __func__ );
	return WFA_SUCCESS;
}

int wfaStaDebugSet(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t *debugResp = &gGenericResp;
	dutCommand_t *debugSet = (dutCommand_t *)caCmdBuf;
	ENTER( __func__ );   
 
	if(debugSet->cmdsu.dbg.state == 1) /* enable */
		wfa_defined_debug |= debugSet->cmdsu.dbg.level;
	else
		wfa_defined_debug = (~debugSet->cmdsu.dbg.level & wfa_defined_debug);

	debugResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)debugResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
	LEAVE( __func__ );
	return TRUE;
}

/*
 *   wfaStaGetBSSID():
 *     This function is to retrieve BSSID of a specific wireless I/F.
 */ 
int wfaStaGetBSSID(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *bssidCmd = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *bssidResp = &gGenericResp;
    int ret;
	char bssid[128] = {0}; 	
	if (MWIFIEX)
		ret = get_mx_bssid_info(mrvl_dut_info->sta_interface,bssid);
	else 
		ret = get_mlan_bssid_info(mrvl_dut_info->sta_interface,bssid);

	if ( ret == FALSE ) {
	    bssidResp->status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, 4, (BYTE *)&bssidResp, respBuf);   
        *respLen = WFA_TLV_HDR_LEN + 4;
		LEAVE( __func__ );
        return WFA_FAILURE;
	} 
    strcpy(bssidResp->cmdru.bssid, bssid); 
    bssidResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)bssidResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
	LEAVE( __func__ );
    return WFA_SUCCESS;
}

/*
 * wfaStaSetIBSS()
 *    This is to set
 *    1. ssid
 *    2. channel
 *    3. encrypType - none or wep
 *    optional
 *    4. key1
 *    5. key2
 *    6. key3
 *    7. key4
 *    8. activeIndex - 1, 2, 3, or 4
 */
int wfaStaSetIBSS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetIBSS_t *setIBSS = (caStaSetIBSS_t *)caCmdBuf;
    dutCmdResponse_t *setIbssResp = &gGenericResp;
    char *ifname = (char *)setIBSS->intf;
    int channel = setIBSS->channel;
    int encpType = setIBSS->encpType;
    int activeKeyIdx = setIBSS->activeKeyIdx;
    char *ssid = (char *)setIBSS->ssid;
	int ret; 
	
	FILE *fp=NULL;
	ENTER( __func__ );
	
	ret = set_mlan_channel(mrvl_dut_info->sta_interface,channel);
    /** 0=none, 1=wep */    
    if (encpType){
		if (mrvl_dut_info->use_supplicant) {
			if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {	
				fp = fopen(SUPPLICANT_CONF,"w");
				if ( fp == NULL ) {
					setIbssResp->status = STATUS_ERROR;
					wfaEncodeTLV(WFA_STA_SET_IBSS_RESP_TLV, 4, (BYTE *)setIbssResp, respBuf);   
					*respLen = WFA_TLV_HDR_LEN + 4;
					return FALSE;
				}
				fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
				fprintf(fp,"ap_scan=1\n");				
				fprintf(fp,"network={\n");
				fprintf(fp,"\tssid=\"%s\"\n",ssid);
				fprintf(fp,"\tkey_mgmt=NONE\n");
				if (setIBSS->keys[0][0] != '\0') {
					fprintf(fp,"\twep_key0=%s\n",setIBSS->keys[0]);
				}
				if (setIBSS->keys[1][0] != '\0') {
					fprintf(fp,"\twep_key1=%s\n",setIBSS->keys[1]);
				}
				if (setIBSS->keys[2][0] != '\0') {
					fprintf(fp,"\twep_key2=%s\n",setIBSS->keys[2]);
				}
				if (setIBSS->keys[3][0] != '\0') {
					fprintf(fp,"\twep_key3=%s\n",setIBSS->keys[3]);
				}
				fprintf(fp,"\twep_tx_keyidx=%d\n",activeKeyIdx);			
				fprintf(fp,"}\n");
				fclose(fp);
				console_dump_file(SUPPLICANT_CONF);
			} else {
				ret = set_wpacli_wep_configuration(setIBSS->keys[0],setIBSS->keys[1],setIBSS->keys[2],setIBSS->keys[3],activeKeyIdx);
			}
		} else {
			ret = set_mlan_wep_configuration(setIBSS->keys[0],setIBSS->keys[1],setIBSS->keys[2],setIBSS->keys[3],activeKeyIdx);	
		}
	} else {
		if (mrvl_dut_info->use_supplicant) {
			if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {
				fp = fopen(SUPPLICANT_CONF,"w");
				if ( fp == NULL ) {
					setIbssResp->status = STATUS_ERROR;
					wfaEncodeTLV(WFA_STA_SET_IBSS_RESP_TLV, 4, (BYTE *)setIbssResp, respBuf);   
					*respLen = WFA_TLV_HDR_LEN + 4;
					return FALSE;
				}
				fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
				fprintf(fp,"ap_scan=1\n");
				fprintf(fp,"network={\n");
				fprintf(fp,"\tssid=\"%s\"\n",ssid);		
				fprintf(fp,"\tkey_mgmt=NONE\n");
				fprintf(fp,"}\n");
				fclose(fp);
				console_dump_file(SUPPLICANT_CONF);
			} else {
				mrvl_WS_info->network_index = get_supplicant_network_index(mrvl_WS_info->sta_ctrl_interface);
				ret= set_wpacli_open_configuration(mrvl_WS_info->sta_ctrl_interface,mrvl_WS_info->network_index,ssid);
			}
		} else {
			ret = set_mlan_open_configuration(mrvl_WS_info->sta_ctrl_interface);
		}
	}
	
    setIbssResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_IBSS_RESP_TLV, 4, (BYTE *)setIbssResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}

/*
 *  wfaSetMode():
 *  The function is to set the wireless interface with a given mode (possible 
 *  adhoc)
 *  Input parameters:
 *    1. I/F
 *    2. ssid
 *    3. mode adhoc or managed
 *    4. encType
 *    5. channel
 *    6. key(s)
 *    7. active  key
 */ 
int wfaStaSetMode(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetMode_t *setmode = (caStaSetMode_t *)caCmdBuf;
    dutCmdResponse_t *SetModeResp = &gGenericResp;
    char *ifname = (char *)setmode->intf;
    int encpType = setmode->encpType;
    int activeKeyIdx = setmode->activeKeyIdx;
    int mode = setmode->mode;
    int channel = setmode->channel;
    char *ssid = (char *)setmode->ssid;
    int ret; 
	
	FILE *fp=NULL;
	ENTER( __func__ );
        		
    /** 0=none, 1=wep */   
    if (encpType) {
		if (mrvl_dut_info->use_supplicant) {
			if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {	
				fp = fopen(SUPPLICANT_CONF,"w");
				if ( fp == NULL ) {
					SetModeResp->status = STATUS_ERROR;
					wfaEncodeTLV(WFA_STA_SET_MODE_RESP_TLV, 4, (BYTE *)SetModeResp, respBuf);
					*respLen = WFA_TLV_HDR_LEN + 4;
					return FALSE;
				}
				fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
				fprintf(fp,"ap_scan=1\n");
				fprintf(fp,"network={\n");
				fprintf(fp,"\tssid=\"%s\"\n",ssid);
				fprintf(fp,"\tkey_mgmt=NONE\n");
				if (setmode->keys[0][0] != '\0') {
					fprintf(fp,"\twep_key0=%s\n",setmode->keys[0]);
				}
				if (setmode->keys[1][0] != '\0') {
					fprintf(fp,"\twep_key1=%s\n",setmode->keys[1]);
				}
				if (setmode->keys[2][0] != '\0') {
					fprintf(fp,"\twep_key2=%s\n",setmode->keys[2]);
				}
				if (setmode->keys[3][0] != '\0') {
					fprintf(fp,"\twep_key3=%s\n",setmode->keys[3]);
				}
				fprintf(fp,"\twep_tx_keyidx=%d\n",activeKeyIdx);
				fprintf(fp,"}\n");
				fclose(fp);
				console_dump_file(SUPPLICANT_CONF);
			} else {
				ret = set_wpacli_wep_configuration(setmode->keys[0],setmode->keys[1],setmode->keys[2],setmode->keys[3],activeKeyIdx);
			}
		} else {
			ret = set_mlan_wep_configuration(setmode->keys[0],setmode->keys[1],setmode->keys[2],setmode->keys[3],activeKeyIdx);	
		}
	} else {
		if (mrvl_dut_info->use_supplicant) { 
			if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {
				fp = fopen(SUPPLICANT_CONF,"w");
				if ( fp == NULL ) {
					SetModeResp->status = STATUS_ERROR;
					wfaEncodeTLV(WFA_STA_SET_MODE_RESP_TLV, 4, (BYTE *)SetModeResp, respBuf);
					*respLen = WFA_TLV_HDR_LEN + 4;
					return FALSE;
				}
				fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
				fprintf(fp,"ap_scan=1\n");
				fprintf(fp,"network={\n");
				fprintf(fp,"\tssid=\"%s\"\n",ssid);		
				fprintf(fp,"\tkey_mgmt=NONE\n");
				fprintf(fp,"}\n");
				fclose(fp);
				console_dump_file(SUPPLICANT_CONF);
			} else {
				mrvl_WS_info->network_index = get_supplicant_network_index(mrvl_WS_info->sta_ctrl_interface);
				ret= set_wpacli_open_configuration(mrvl_WS_info->sta_ctrl_interface,mrvl_WS_info->network_index,ssid);
			}
		} else {
			ret = set_mlan_open_configuration(mrvl_WS_info->sta_ctrl_interface);
		}
	}
	
	if(setmode->channel) {
		ret = set_mlan_channel(mrvl_dut_info->sta_interface,channel);
    }
    if(setmode->mode) {
		ret = set_mlan_mode(mrvl_dut_info->sta_interface,1);
	} else {
		ret = set_mlan_mode(mrvl_dut_info->sta_interface,0);		
	}
	
    SetModeResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_MODE_RESP_TLV, 4, (BYTE *)SetModeResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}

int wfaStaSetPwrSave(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPwrSave_t *setps = (caStaSetPwrSave_t *)caCmdBuf;
   dutCmdResponse_t *SetPSResp = &gGenericResp;
   int ret;
   
   ENTER( __func__ ); 
   ret = configure_powersave_mode(mrvl_dut_info->sta_interface,1);   
   SetPSResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PWRSAVE_RESP_TLV, 4, (BYTE *)SetPSResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
   LEAVE( __func__ );
   return TRUE;
}

int wfaStaSetPowerSave(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPowerSave_t *setps = (caStaSetPowerSave_t *)caCmdBuf;
   dutCmdResponse_t *SetPSResp = &gGenericResp;
   int ret;
   
   ENTER( __func__ ); 
   DPRINT_INFO(WFA_OUT,"\n the PS FLAG value is ---\"%d\"----",setps->ps_flag);
   ret = configure_powersave_mode(mrvl_dut_info->sta_interface,setps->ps_flag);   
   SetPSResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_POWERSAVE_RESP_TLV, 4, (BYTE *)SetPSResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
   LEAVE( __func__ );
   return TRUE;
}


int wfaStaUpload(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaUpload_t *upload = &((dutCommand_t *)caCmdBuf)->cmdsu.upload;
   dutCmdResponse_t *upLoadResp = &gGenericResp;
   caStaUploadResp_t *upld = &upLoadResp->cmdru.uld;
   ENTER( __func__ ); 
   if(upload->type == WFA_UPLOAD_VHSO_RPT)
   {
       int rbytes;
       /*
        * if asked for the first packet, always to open the file
        */
       if(upload->next == 1)
       {
          if(e2efp != NULL)
          {
              fclose(e2efp);
              e2efp = NULL;
          }
          e2efp = fopen(e2eResults, "r");
       }

       if(e2efp == NULL)
       {
           upLoadResp->status = STATUS_ERROR;
           wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;
           return FALSE;
       }
        
       rbytes = fread(upld->bytes, 1, 256, e2efp); 
       if(rbytes < 256)  
       {
           /* 
            * this means no more bytes after this read
            */
           upld->seqnum = 0;
           fclose(e2efp);
           e2efp=NULL;
       }
       else
       { 
           upld->seqnum = upload->next;
       }
       upld->nbytes = rbytes;
       upLoadResp->status = STATUS_COMPLETE;
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   }
   else
   {
       upLoadResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;
   }
   LEAVE( __func__ );
   return TRUE;
}
/*
 * wfaStaSetWMM()
 *  TO be ported on a specific plaform for the DUT
 *  This is to set the WMM related parameters at the DUT.
 *  Currently the function is used for GROUPS WMM-AC and WMM general configuration for setting RTS Threshhold, Fragmentation threshold and wmm (ON/OFF)
 *  It is expected that this function will set all the WMM related parametrs for a particular GROUP .
 */

int wfaStaSetWMM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	ENTER( __func__ ); 
#ifdef WFA_WMM_AC
    caStaSetWMM_t *setwmm = (caStaSetWMM_t *)caCmdBuf;
    char *ifname = setwmm->intf;
    dutCmdResponse_t *setwmmResp = &gGenericResp;
	int ret;
    //IEEEtypes_WMM_TSPEC_t tspec;

    switch(setwmm->group) {
		case GROUP_WMMAC:
			if (setwmm->send_trig){
				int Sockfd;
				struct sockaddr_in psToAddr;
				unsigned int TxMsg[512];
				 
				Sockfd = wfaCreateUDPSock(setwmm->dipaddr, 12346);
				memset(&psToAddr, 0, sizeof(psToAddr));
				psToAddr.sin_family = AF_INET;
				psToAddr.sin_addr.s_addr = inet_addr(setwmm->dipaddr);
				psToAddr.sin_port = htons(12346);

				switch (setwmm->trig_ac) {
					case WMMAC_AC_VO:
						wfaTGSetPrio(Sockfd, 7);
						create_apts_msg(APTS_CK_VO, TxMsg, 0);
						DPRINT_INFO(WFA_OUT,"\r\nSending AC_VO trigger packet\n");
						break;

					case WMMAC_AC_VI:
						wfaTGSetPrio(Sockfd, 5);
						create_apts_msg(APTS_CK_VI, TxMsg, 0);
						DPRINT_INFO(WFA_OUT,"\r\nSending AC_VI trigger packet\n");
						break;

					case WMMAC_AC_BK:
						wfaTGSetPrio(Sockfd, 2);
						create_apts_msg(APTS_CK_BK, TxMsg, 0);
						DPRINT_INFO(WFA_OUT,"\r\nSending AC_BK trigger packet\n");
						break;

					default:
						case WMMAC_AC_BE:
						wfaTGSetPrio(Sockfd, 0);
						create_apts_msg(APTS_CK_BE, TxMsg, 0);
						DPRINT_INFO(WFA_OUT,"\r\nSending AC_BE trigger packet\n");
						break;
						}

					sendto(Sockfd, TxMsg, 256, 0, (struct sockaddr *)&psToAddr,
						   sizeof(struct sockaddr));
					close(Sockfd);
					usleep(1000000);
				} else if (setwmm->action == WMMAC_ADDTS) {
					   //wmmtspec_t* pCmdTspec = &(setwmm->actions.addts.tspec);
					   DPRINT_INFO(WFA_OUT,"ADDTS AC PARAMS: dialog id: %d, TID: %d, "
										"DIRECTION: %d, PSB: %d, UP: %d, "
										"Fixed %d, MSDU Size: %d, Max MSDU Size %d, "
										"MIN SERVICE INTERVAL: %d, MAX SERVICE INTERVAL: %d, "
										"INACTIVITY: %d, SUSPENSION %d, SERVICE START TIME: %d, "
										"MIN DATARATE: %d, MEAN DATA RATE: %d, PEAK DATA RATE: %d, "
										"BURSTSIZE: %d, DELAY BOUND: %d, PHYRATE: %d, SPLUSBW: %f, "
										"MEDIUM TIME: %d, ACCESSCAT: %d\n",
					   setwmm->actions.addts.dialog_token,
					   setwmm->actions.addts.tspec.tsinfo.TID,
					   setwmm->actions.addts.tspec.tsinfo.direction,
					   setwmm->actions.addts.tspec.tsinfo.PSB,
					   setwmm->actions.addts.tspec.tsinfo.UP,
					   setwmm->actions.addts.tspec.Fixed,
					   setwmm->actions.addts.tspec.size,
					   setwmm->actions.addts.tspec.maxsize,
					   setwmm->actions.addts.tspec.min_srvc,
					   setwmm->actions.addts.tspec.max_srvc,
					   setwmm->actions.addts.tspec.inactivity,
					   setwmm->actions.addts.tspec.suspension,
					   setwmm->actions.addts.tspec.srvc_strt_tim,
					   setwmm->actions.addts.tspec.mindatarate,
					   setwmm->actions.addts.tspec.meandatarate,
					   setwmm->actions.addts.tspec.peakdatarate,
					   setwmm->actions.addts.tspec.burstsize,
					   setwmm->actions.addts.tspec.delaybound,
					   setwmm->actions.addts.tspec.PHYrate,
					   setwmm->actions.addts.tspec.sba,
					   setwmm->actions.addts.tspec.medium_time,
					   setwmm->actions.addts.accesscat);
					}
					else if (setwmm->action == WMMAC_DELTS) {
						/** send del tspec */ 
					}
			setwmmResp->status = STATUS_COMPLETE;
			break;

		case GROUP_WMMCONF:
			ret = configure_wmm_group(mrvl_dut_info->sta_interface,setwmm->actions.config.rts_thr,setwmm->actions.config.frag_thr,setwmm->actions.config.wmm);
			setwmmResp->status = STATUS_COMPLETE;
			break;

		default:
			DPRINT_ERR(WFA_ERR, "The group %d is not supported\n",setwmm->group);
			setwmmResp->status = STATUS_ERROR;
			break;
    }
    wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
#endif
    LEAVE( __func__ );
    return TRUE;
}

int wfaStaSendNeigReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *sendNeigReq = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *sendNeigReqResp = &gGenericResp;
   ENTER( __func__ ); 
   /** TODO */
   
   
   sendNeigReqResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SEND_NEIGREQ_RESP_TLV, 4, (BYTE *)sendNeigReqResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
   LEAVE( __func__ );
   return TRUE;
}

int wfaStaSetEapFAST(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapFAST_t *setFAST= (caStaSetEapFAST_t *)caCmdBuf;
    dutCmdResponse_t *setEapFastResp = &gGenericResp;
    char *ifname = setFAST->intf;
    char *ssid = setFAST->ssid;
    char *encrptype = setFAST->encrptype;
    char *keyMgmtType = setFAST->keyMgmtType;
    char *trustedRootCA = setFAST->trustedRootCA;
    char *username = setFAST->username;
    char *passwd = setFAST->passwd;
    char *innerEAP = setFAST->innerEAP;
    char *pacFileName = setFAST->pacFileName;
	int ret; 
	
	FILE *fp=NULL;
	ENTER( __func__ );
	
	if (mrvl_dut_info->use_supplicant) {
		if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {	
			fp = fopen(SUPPLICANT_CONF,"w");
			if ( fp == NULL ) {
				DPRINT_ERR(WFA_ERR,"File Opening error");
			    setEapFastResp->status = STATUS_ERROR;
				wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);
				*respLen = WFA_TLV_HDR_LEN + 4;
				return WFA_FAILURE;
			}
			fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
			fprintf(fp,"ap_scan=1\n");
			fprintf(fp,"network={\n");
			fprintf(fp,"\tssid=\"%s\"\n",ssid);				
			fprintf(fp,"\tkey_mgmt=WPA-EAP\n");	
			configure_supplicant_security_mode (fp,encrptype,keyMgmtType,ssid);
			fprintf(fp,"\teap=FAST\n");
			fprintf(fp,"\tpac_file=\"%s\"\n",pacFileName);
			fprintf(fp,"\tphase1=\"fast_provisioning=2\"\n");
			fprintf(fp,"\tphase2=\"auth=%s\"\n",innerEAP);
			fprintf(fp,"\tidentity=\"%s\"\n",username);
			fprintf(fp,"\tpassword=\"%s\"\n",passwd);
			fprintf(fp,"\tca_cert=\"%s.pem\"\n",trustedRootCA);
			fprintf(fp,"\tanonymous_identity=\"anonymous\"\n");
			fprintf(fp,"}\n");
			fclose(fp);	
			console_dump_file(SUPPLICANT_CONF);
		} else {
			/** TODO */
			return WFA_FAILURE;
		}
	} else {
		/** TODO */
		return WFA_FAILURE;
	}
	runtime_test_data->eap_test =1;
    setEapFastResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}

int wfaStaSetEapAKA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapAKA_t *setAKA= (caStaSetEapAKA_t *)caCmdBuf;
    dutCmdResponse_t *setEapAkaResp = &gGenericResp;
    char *ifname = setAKA->intf;
    char *ssid = setAKA->ssid;
    char *encrptype = setAKA->encrptype;
    char *keyMgmtType = setAKA->keyMgmtType;
    char *username = setAKA->username;
    char *passwd = setAKA->passwd;
	int ret; 
	
	
	FILE *fp=NULL;
	ENTER( __func__ );

	if (mrvl_dut_info->use_supplicant) {
		if ( mrvl_WS_info->supplicant_config_approach != WPA_CLI_APPROACH ) {	
			fp = fopen(SUPPLICANT_CONF,"w");
			if ( fp == NULL ) {
				DPRINT_ERR(WFA_ERR,"File Opening error");
				setEapAkaResp->status = STATUS_ERROR;
				wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);
				*respLen = WFA_TLV_HDR_LEN + 4;
				return WFA_FAILURE;
			}
			fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
			fprintf(fp,"ap_scan=1\n");			
			fprintf(fp,"network={\n");
			fprintf(fp,"\tssid=\"%s\"\n",ssid);
			fprintf(fp,"\tkey_mgmt=WPA-EAP\n");			
			configure_supplicant_security_mode (fp,encrptype,keyMgmtType,ssid);
			
			/** According to RFC 5448, if the leading character in username is 6 , 7 or 8 then the station shall use AKA' */
			if ( !strncmp(username,"6",1) || !strncmp(username,"7",1) || !strncmp(username,"8",1) ) {
				fprintf(fp,"\teap=AKA'\n");
			} else {
				fprintf(fp,"\teap=AKA\n");
			}
			fprintf(fp,"\tphase1=\"result_ind=1\"\n");
			fprintf(fp,"\tidentity=\"%s\"\n",username);
			fprintf(fp,"\tpassword=\"%s\"\n",passwd);
			fprintf(fp,"}\n");
			fclose(fp);	
			console_dump_file(SUPPLICANT_CONF);		
		} else {
			return WFA_FAILURE;
		}
	} else {
		return WFA_FAILURE;
	}
		runtime_test_data->eap_test =1;
    setEapAkaResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}


int wfaStaSetSystime(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetSystime_t *systime = (caStaSetSystime_t *)caCmdBuf;
   dutCmdResponse_t *setSystimeResp = &gGenericResp;
   int ret;
   ENTER( __func__ );


   ret=set_dut_date(systime->month,systime->date,systime->year);
   ret=set_dut_time(systime->hours,systime->minutes,systime->seconds);


   setSystimeResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_SYSTIME_RESP_TLV, 4, (BYTE *)setSystimeResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
   LEAVE( __func__ );
   return TRUE;
}


#ifdef WFA_STA_TB
int wfaStaPresetParams(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *PresetParamsResp = &gGenericResp;
    caStaPresetParameters_t *presetParams = (caStaPresetParameters_t *)caCmdBuf;
   
    int ret;
    unsigned char mode = 0;
	ENTER( __func__ );  
	if (presetParams->wirelessMode == eModeAC) {
		strcpy(saved_txsp_stream, "");
		strcpy(saved_mcs_fixed_rate, "");
	}
    if (presetParams->wmmFlag) {	
		ret = process_generic_mlanutl_cmd(mrvl_dut_info->sta_interface,"wmmcfg",presetParams->wmmFlag);
    }
	
    if (presetParams->modeFlag) {
        if (presetParams->wirelessMode == eModeB) {
            mode |= (1 << 0);
        } else if (presetParams->wirelessMode == eModeBG) {
            mode |= (1 << 0);
            mode |= (1 << 1);
        } else if (presetParams->wirelessMode == eModeA) {
            mode |= (1 << 2);
        } else if (presetParams->wirelessMode == eModeABG) {
            mode |= (1 << 0);
            mode |= (1 << 1);
            mode |= (1 << 2);
        } else if (presetParams->wirelessMode == eModeAN) {
            mode |= (1 << 2);
            mode |= (1 << 4);
        } else if (presetParams->wirelessMode == eModeGN) {
            mode |= (1 << 0);
            mode |= (1 << 1);
            mode |= (1 << 3);
        } else if (presetParams->wirelessMode == eModeNL) {
            mode |= (1 << 0);
            mode |= (1 << 1);
            mode |= (1 << 2);
            mode |= (1 << 3);
            mode |= (1 << 4);
        } else if (presetParams->wirelessMode == eModeAC) {	
            mode |= (1 << 2);
            mode |= (1 << 4);
            mode |= (1 << 6);
        }
		if (presetParams->wirelessMode == eModeHE) {
		ret = process_generic_mlanutl_cmd(mrvl_dut_info->sta_interface,"bandcfg",895);
		} 

       else if (presetParams->wirelessMode == eModeAC) {
			ret = process_generic_mlanutl_cmd(mrvl_dut_info->sta_interface,"bandcfg",84);
        } 
	else {
			ret = process_generic_mlanutl_cmd(mrvl_dut_info->sta_interface,"bandcfg",mode);			
		}

    }
	
    if(presetParams->psFlag) {
		/** enable / disable feature */	
    }
    if (presetParams->program == PROG_TYPE_MBO) {
		runtime_test_data->eap_test =0;
		if (presetParams->Roaming_Flag) {
		}
		if (presetParams->Cellular_Data_Cap_Flag) {
			sprintf(gCmdStr,"./%s -i%s set mbo_cell_capa %d",mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->sta_ctrl_interface,presetParams->Cellular_Data_Cap);
			system_with_log(gCmdStr);
		}
		if (presetParams->BSS_Transition_Flag) {
			sprintf(gCmdStr,"./%s -i%s set reject_btm_req_reason %d",mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->sta_ctrl_interface,!presetParams->BSS_Transition);
			system_with_log(gCmdStr);
		}
		if (presetParams->Assoc_Disallow_Flag) {
			sprintf(gCmdStr,"./%s -i%s set ignore_assoc_disallow %d",mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->sta_ctrl_interface,!presetParams->Assoc_Disallow);
			system_with_log(gCmdStr);
		}
		if (presetParams->Ch_Op_Class_Flag) {
			sprintf(gCmdStr,"%d:%d:%d:%d ",
					presetParams->Ch_Op_Class,
					presetParams->Ch_Pref_Num,
					presetParams->Ch_Pref,
					presetParams->Ch_Reason_Code);
			strcat(runtime_test_data->preset_non_pref_chan_list,gCmdStr);
		}
		if (presetParams->ftoa_flag) {
			if(presetParams->ftoa == eEnable) {
				sprintf(gCmdStr, "./%s -i %s DRIVER ROAM 1",
							mrvl_WS_info->supplicant_cli_bin,
							mrvl_WS_info->sta_ctrl_interface);
				system_with_log(gCmdStr);
				runtime_test_data->roam =1;
			} else {
			}		
		}
	}
    if(presetParams->program == PROG_TYPE_VENT) {
		if(presetParams->ftoa == eEnable) {
			/** enable Fast BSS Transition Over the Air */
		} else {
			/** disable Fast BSS Transition Over the Air */
		}

	    if(presetParams->ftds == eEnable) {
		  /** enable Fast BSS Transition Over the DS */
	    } else {
		  /** disable Fast BSS Transition Over the DS */
	    }

	    if(presetParams->activescan == eEnable) {
	      /** Enable Active Scan on STA */
	    } else {
	      /** disable Active Scan on STA */ 
	    }
    }
     
    if(presetParams->program == PROG_TYPE_WFD) {
	   if(presetParams->tdlsFlag) {
	      /** enable / disable tdls based on tdls */
	   }
	   if(presetParams->wfdDevTypeFlag){
	      /** set WFD device type to source/sink/dual based on wfdDevType */
	   }
	   if(presetParams->wfdUibcGenFlag){
	      /** enable / disable the feature */
	   }
	   if(presetParams->wfdUibcHidFlag){
	      /** enable / disable feature */
	   }
	   if(presetParams->wfdUiInputFlag){
	      /** set the UI input as mentioned */
	   }
	   if(presetParams->wfdHdcpFlag){
	      /** enable / disable feature */
	   }
	   if(presetParams->wfdFrameSkipFlag){
	      /** enable / disable feature */
	   }
	   if(presetParams->wfdAvChangeFlag){
	      /** enable / disable feature */
	   }
	   if(presetParams->wfdStandByFlag){
	      /** enable / disable  */
	   }
	   if(presetParams->wfdInVideoFlag){
	      /** select the input vide as protecteed or non-protetcted or protected audio
	       or unprotected audio etc. */
	   }
	   if(presetParams->wfdVideoFmatFlag){
		  /** set the video format as requested */
	   }
	   if(presetParams->wfdAudioFmatFlag) {
		  /** set the Audio format as requested */
	   }
	   if(presetParams->wfdI2cFlag) {
	      /** enable / disable feature */
	   }
	   if(presetParams->wfdVideoRecoveryFlag){
	      /** enable / disable feature */
	   }
	   if(presetParams->wfdPrefDisplayFlag){
	      /** enable / disable feature */
	   }
	   if(presetParams->wfdServiceDiscoveryFlag){
	      /** enable / disable feature */
	   }
	   if(presetParams->wfd3dVideoFlag){
	      /** enable / disable feature */
	   }
	   if(presetParams->wfdMultiTxStreamFlag){
	      /** enable / disable feature */
	   }
	   if(presetParams->wfdTimeSyncFlag){
	      /** enable / disable feature */
	   }
	   if(presetParams->wfdEDIDFlag){
	      /** enable / disable feature */
	   }
	   if(presetParams->wfdUIBCPrepareFlag){
	      /** Provides information to start valid WFD session to check UIBC operation. */
	   }
	   if(presetParams->wfdCoupledCapFlag){
	       /** enable / disable feature */
	   }
	   if(presetParams->wfdOptionalFeatureFlag){
	      /** disable all program specific optional features */
	   }
	   if(presetParams->wfdSessionAvailFlag){
	      /** enable / disable session available bit */ 
	   }
       if(presetParams->wfdDeviceDiscoverabilityFlag){
	       /** enable / disable feature */
	   }
    }

	if(presetParams->program == PROG_TYPE_HS2) {
		if( presetParams->wfdPpsMoId != 0) {

		}
    	if(strncmp(presetParams->fileType,"PPSMO", 5) == 0) {
        	if( strncmp(presetParams->filePath, "http", 4) == 0){
				ret = download_certificate(presetParams->fileName,presetParams->filePath,"pps-tnds.xml");
  	      	} else if(strncmp(presetParams->filePath, "VendorSpecific", 14) == 0){
  	
        	}
 			ret = generate_ppsmo_client_certificate(mrvl_WS_info->sta_ctrl_interface,"pps-tnds.xml");
    	}

		if(strncmp(presetParams->fileType,"CERT", 4) == 0) {
    		if( strncmp(presetParams->filePath, "http", 4) == 0){
				strcat(presetParams->fileName,".pem");
				ret = download_certificate(presetParams->fileName,presetParams->filePath,"next-client-cert.pem");
				ret = install_certificate("next-client-cert.pem","client-key.pem");
				ret = install_certificate("next-client-cert.pem","client-cert.pem");
  	      	}
		}		
		if(presetParams->program == PROG_TYPE_HS2 && presetParams->provisioningProto != '\0') {
		    if(strcmp(presetParams->provisioningProto, "SOAP") == 0){

		    } else if(strcmp(presetParams->provisioningProto, "OMADM") == 0){

		    }
		}
	}

	PresetParamsResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return WFA_SUCCESS;
}

int wfaStaSetWireless(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staWirelessResp = &gGenericResp;
    caStaSetWireless_t *staSetWireless = (caStaSetWireless_t *)caCmdBuf;
	int ret;	
    
	ENTER( __func__ ); 
	if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_VHT_PROG) ) {
		ret = configure_vht_settings(len, caCmdBuf, respLen, respBuf);
	}
	if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_HE_PROG) ) {
		ret = configure_he_settings(len, caCmdBuf, respLen, respBuf);
	}
	if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_11N_PROG) ) {
		ret = configure_11n_settings(len, caCmdBuf, respLen, respBuf);
	} 
	if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_PMF_PROG) ) {
		/** TODO */
	}
	if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_WMM_PS_PROG) ) {
		/** TODO */
	}
	if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_TDLS_PROG) ) {
		/** TODO */
	}
		
    if(ret == WFA_FAILURE)
		staWirelessResp->status = STATUS_ERROR;
    else
        staWirelessResp->status = STATUS_COMPLETE;       	
    wfaEncodeTLV(WFA_STA_SET_WIRELESS_RESP_TLV, 4, (BYTE *)staWirelessResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return WFA_SUCCESS;
}

int wfaStaSendADDBA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staSendADDBAResp = &gGenericResp;
	ENTER( __func__ ); 

    /** TODO */

    staSendADDBAResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_SEND_ADDBA_RESP_TLV, 4, (BYTE *)staSendADDBAResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}

int wfaStaSetRIFS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t *staSetRIFSResp = &gGenericResp;
	ENTER( __func__ ); 

	wfaEncodeTLV(WFA_STA_SET_RIFS_TEST_RESP_TLV, 4, (BYTE *)staSetRIFSResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
	return TRUE;
}

int wfaStaSendCoExistMGMT(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staSendMGMTResp = &gGenericResp;
	ENTER( __func__ ); 
    
	wfaEncodeTLV(WFA_STA_SEND_COEXIST_MGMT_RESP_TLV, 4, (BYTE *)staSendMGMTResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}

int wfaStaResetDefault(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaResetDefault_t *reset = (caStaResetDefault_t *)caCmdBuf;
	dutCmdResponse_t *ResetResp = &gGenericResp;
	int ret; 
	FILE *fp=NULL;
	
	ENTER( __func__ ); 
	ret = kill_wlan_utilities();

	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_VHT_PROG)) {
		ret = reload_wlan_build();
		if (!MWIFIEX) {
			ret = preset_vht_parameters(len,caCmdBuf,respLen,respBuf);
		}
	} 
	
	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_WFD_PROG)) {
		/** TODO */
		launch_supplicant_file_instance( mrvl_dut_info->p2p_interface );
		sleep(1);
		// Fix 4.1.1
		preset_wfd( mrvl_dut_info->p2p_interface );
	} 

	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_11N_PROG)) {
		ret = reload_wlan_build();
	} 
	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_HE_PROG)) {
		/*DPRINT_INFO(WFA_OUT,"Divesh:Reload the build for HE-STA");*/
		ret = reload_wlan_build();
	} 

	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_PMF_PROG)) {
		ret = reload_wlan_build();
	} 
	
	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_WMM_PS_PROG)) {
		ret = reload_wlan_build();
	}
	
	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_TDLS_PROG)) {
		ret = reload_wlan_build();
	}
 /* DD Change to invoke WPA_SUPPLCIANT for WPA3 */
	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_MBO_PROG) || !strcasecmp(SIGMA_PROG_NAME,MRVL_WPA3_PROG)) {
		ret = reload_wlan_build();
		fp = fopen(SUPPLICANT_CONF,"w");
		if ( fp != NULL ) {
			fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
			//fprintf(fp,"pmf=1\n");
			fprintf(fp,"update_config=1\n");
			fprintf(fp,"interworking=1\n");
			fprintf(fp,"ap_scan=1\n");		
			fprintf(fp,"gas_address3=1\n");
			fclose(fp);				
		}
		console_dump_file(SUPPLICANT_CONF);
		ret = launch_supplicant_file_instance(mrvl_dut_info->sta_interface,0);
		mrvl_WS_info->network_index =0;
		runtime_test_data->eap_test =0;
		runtime_test_data->roam =0;
		runtime_test_data->preset_non_pref_chan_list[0] = '\0';
		runtime_test_data->rfeat_non_pref_chan_list[0] = '\0';
		}
	
		if (!strcasecmp(SIGMA_PROG_NAME,MRVL_HE_PROG)) {
		ret = reload_wlan_build();
		fp = fopen(SUPPLICANT_CONF,"w");
		if ( fp != NULL ) {
			fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
			fprintf(fp,"update_config=1\n");
			fprintf(fp,"ap_scan=1\n");		
			fclose(fp);				
		}
		console_dump_file(SUPPLICANT_CONF);
		
		ret = launch_supplicant_file_instance(mrvl_dut_info->sta_interface,0);
		mrvl_WS_info->network_index =0;
			}
	
	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_HS2_PROG)) {
		fp = fopen(SUPPLICANT_CONF,"w");
		if ( fp != NULL ) {
			fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);
			fprintf(fp,"update_config=1\n");
			fprintf(fp,"min_rssi_low=70\n");
			fprintf(fp,"max_rssi_low=82\n");
			fprintf(fp,"rssi_step=6\n");
			fprintf(fp,"bgscan_interval=30\n");
			fprintf(fp,"bgscan_count=5\n");
			fprintf(fp,"hs20=1\n");
			fprintf(fp,"interworking=1\n");
			fclose(fp);	
		} else {
			ResetResp->status = STATUS_ERROR;
			return FALSE;
		}
		ret = reload_wlan_build();
		ret = configure_powersave_mode(mrvl_dut_info->sta_interface,0);
		ret = launch_supplicant_file_instance(mrvl_dut_info->sta_interface,0);
		ret = init_hs2_capabilities(mrvl_WS_info->sta_ctrl_interface);
		ret = reset_ip_tables(mrvl_dut_info->sta_interface);

		mrvl_WS_info->credential_index =0;
		mrvl_WS_info->network_index =0;
		runtime_test_data->dhcp =0;		
	}
	
	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_V_E_PROG)) {
		ret = reload_wlan_build();
		ret = configure_11k_mode(mrvl_WS_info->sta_ctrl_interface,1);
	}
		
	ResetResp->status = STATUS_COMPLETE;
	if ( ret == FALSE ) {
		ResetResp->status = STATUS_ERROR;
	}
	wfaEncodeTLV(WFA_STA_RESET_DEFAULT_RESP_TLV, 4, (BYTE *)ResetResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}

#else
int wfaStaTestBedCmd(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staCmdResp = &gGenericResp;
	ENTER( __func__ ); 
	
    wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}
#endif





/*
 * This is used to set a temporary MAC address of an interface
 */
int wfaStaSetMacAddr(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *cmd = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *staCmdResp = &gGenericResp;
   char *macaddr = &cmd->cmdsu.macaddr[0];
   ENTER( __func__ );
   /** TODO */
   
   wfaEncodeTLV(WFA_STA_SET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
   LEAVE( __func__ );
   return TRUE;
}

int wfaStaDisconnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *disc = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *staDiscResp = &gGenericResp;
	int ret;
	ENTER( __func__ );
	if (mrvl_dut_info->use_supplicant) {
		ret = supplicant_disconnect(mrvl_WS_info->sta_ctrl_interface);
	} else {
		ret = set_mlan_deauth(mrvl_dut_info->sta_interface);
	}
    staDiscResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)staDiscResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    LEAVE( __func__ );
    return TRUE;
}

void wfaSendPing(tgPingStart_t *staPing, float *interval, int streamid)
{
    int totalpkts;
    char cmdStr[128];
#ifdef WFA_PC_CONSOLE
    char addr[40];
    char bflag[] = "-b";
    char *tmpstr;
    int inum=0;
#else
    char bflag[] = "  ";
#endif
    totalpkts = staPing->duration * staPing->frameRate;
	ENTER( __func__ );
	
#ifdef WFA_PC_CONSOLE
    printf("\nCS : The Stream ID is %d",streamid);
    printf("\nCS :the addr is %s ",addr);
    strcpy(addr,staPing->dipaddr);
    printf("\nCS :Inside the WFA_PC_CONSLE BLOCK");
    printf("\nCS :the addr is %s ",addr);
    tmpstr = strtok(addr, ".");
    inum = atoi(tmpstr);
    printf("interval %f\n", *interval);
    if(inum >= 224 && inum <= 239) // multicast
    {
	
    }
    else // if not MC, check if it is BC address
    {
       printf("\nCS :Inside the BC address BLOCK");
       printf("\nCS :the inum %d",inum);
       strtok(NULL, ".");
       tmpstr = strtok(NULL, ".");
       printf("tmpstr %s\n", tmpstr);
       inum = atoi(tmpstr);
       printf("\nCS : The string is %s",tmpstr);
       if(inum != 255)
          memset(bflag, 0, strlen(bflag));
    }
#endif
	printf("\nCS : The Stream ID is %d",streamid);
	sprintf(cmdStr, "echo streamid=%i > /tmp/spout_%d.txt", streamid, streamid);
	system_with_log(cmdStr);
	
  	if(staPing->dscp == 0){
		if(staPing->iptype == 2){
			#ifdef MV_PLATFORM_ANDROID
			sprintf(cmdStr, "busybox ash wfaping6.sh %s -i %f -c %i -s %i -q %s  >> /tmp/spout_%d.txt 2>/dev/null",bflag, *interval, totalpkts, staPing->frameSize, staPing->dipaddr, streamid);
			#else
			sprintf(cmdStr, "sh wfaping6.sh %s %s -i %f -c %i -s %i -q >> /tmp/spout_%d.txt 2>/dev/null",bflag, staPing->dipaddr, *interval, totalpkts, staPing->frameSize, streamid);
			#endif
		} else {
			#ifdef MV_PLATFORM_ANDROID
			sprintf(cmdStr, "busybox ash wfaping.sh %s -i %f -c %i -s %i -q %s  >> /tmp/spout_%d.txt 2>/dev/null",bflag, *interval, totalpkts, staPing->frameSize, staPing->dipaddr, streamid);
			#else
			sprintf(cmdStr, "sh wfaping.sh %s %s -i %f -c %i -s %i -q >> /tmp/spout_%d.txt 2>/dev/null",bflag, staPing->dipaddr, *interval, totalpkts, staPing->frameSize, streamid);
			#endif
		}
   	} else {
    	#ifdef MV_PLATFORM_ANDROID
    	sprintf(cmdStr, "busybox ash wfaping.sh %s -i %f -c %i -s %i -q %s -Q 88 >> /tmp/spout_%d.txt 2>/dev/null",bflag, *interval, totalpkts, staPing->frameSize, staPing->dipaddr, streamid);
    	#else
    	sprintf(cmdStr, "sh wfaping.sh %s %s -i %f -c %i -s %i -q -Q 88>> /tmp/spout_%d.txt 2>/dev/null",bflag, staPing->dipaddr, *interval, totalpkts, staPing->frameSize, streamid);
    	#endif
    }
	system_with_log(cmdStr);
		
#ifdef MV_PLATFORM_ANDROID
	sprintf(cmdStr, "busybox ash updatepid.sh /tmp/spout_%d.txt",streamid);
#else
	sprintf(cmdStr, "sh updatepid.sh /tmp/spout_%d.txt",streamid);
#endif	
	system_with_log(cmdStr);
	LEAVE( __func__ );
}

int wfaStopPing(dutCmdResponse_t *stpResp, int streamid)
{
    char strout[256];
    FILE *tmpfile = NULL;
    char cmdStr[128];
    printf("Ping stop id %d\n", streamid);
	ENTER( __func__ );
#ifdef MV_PLATFORM_ANDROID
	sprintf(cmdStr, "busybox ash getpid.sh /tmp/spout_%d.txt /tmp/pid.txt",streamid); 
#else
	sprintf(cmdStr, "sh getpid.sh /tmp/spout_%d.txt /tmp/pid.txt",streamid);
#endif
	system_with_log(cmdStr);
	
#ifdef MV_PLATFORM_ANDROID
	sprintf(gCmdStr,"busybox ash stoping.sh /tmp/pid.txt ; sleep 2"); 
	system_with_log(gCmdStr);
#else
    sprintf(gCmdStr,"sh stoping.sh /tmp/pid.txt ; sleep 2"); 
    system_with_log(gCmdStr);
#endif
	
#ifdef MV_PLATFORM_ANDROID
	sprintf(cmdStr, "busybox ash getpstats.sh /tmp/spout_%d.txt",streamid);
#else
	sprintf(cmdStr, "sh getpstats.sh /tmp/spout_%d.txt",streamid);
#endif
	system_with_log(cmdStr);

	tmpfile = fopen("/tmp/stpsta.txt", "r+");
	if(tmpfile == NULL) {
        return FALSE;
	}

    if(fscanf(tmpfile, "%s", strout) != EOF) {
        if(*strout == '\0') {
            stpResp->cmdru.pingStp.sendCnt = 0;
        } else
            stpResp->cmdru.pingStp.sendCnt = atoi(strout);
    }
    printf("after scan sent count %i\n", stpResp->cmdru.pingStp.sendCnt);
    if(fscanf(tmpfile, "%s", strout) != EOF){
        if(*strout == '\0') {
            stpResp->cmdru.pingStp.repliedCnt = 0;
        } else
            stpResp->cmdru.pingStp.repliedCnt = atoi(strout);
    }
    printf("after scan replied count %i\n", stpResp->cmdru.pingStp.repliedCnt);
    fclose(tmpfile);
	LEAVE( __func__ );
    return TRUE;
}

/*
 * wfaStaGetP2pDevAddress(): 
 */
int wfaStaGetP2pDevAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf;
	int ret; 
	
    ENTER( __func__ );
	ret = fetch_mac_address(mrvl_dut_info->p2p_interface,mrvl_dut_info->p2p_dev_address);
	strcpy(infoResp.cmdru.devid,mrvl_dut_info->p2p_dev_address);
	infoResp.status = STATUS_COMPLETE;
	
	if ( ret == FALSE ) {
		infoResp.status = STATUS_ERROR;
	}
    wfaEncodeTLV(WFA_STA_P2P_GET_DEV_ADDRESS_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
    LEAVE( __func__ );
    return TRUE;
}

int wfaStaSetP2p(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf) {
    dutCmdResponse_t infoResp;
    caStaSetP2p_t *getStaSetP2p = (caStaSetP2p_t *)caCmdBuf; 
  	int ret; 
    ENTER( __func__ );
	
	if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
		ret = fetch_mwud_wifidirect_capabilities(mrvl_dut_info->p2p_interface);	
	}

	if (getStaSetP2p->listen_chn_flag == 1) { 
        if(getStaSetP2p->listen_chn == 0) {
			getStaSetP2p->listen_chn =DEFAULT_CHAN;
        }
		if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
			ret = set_supplicant_listen_channel(mrvl_WS_info->p2p_ctrl_interface,getStaSetP2p->listen_chn);
		}
		runtime_test_data->listen_chn =getStaSetP2p->listen_chn;		
        }
		
	if (getStaSetP2p->presistent_flag == 1) {
		if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT) && getStaSetP2p->presistent) {
			ret = enable_supplicant_persistent_mode(mrvl_WS_info->p2p_ctrl_interface);
		} else if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
			runtime_test_data->grpCapability |= (0x01 << 1);
		}
	}			
	
	if (getStaSetP2p->crossconnection == 1) {
		if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
			ret = enable_supplicant_cross_connect(mrvl_WS_info->p2p_ctrl_interface);
		} else if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
			/** TODO */
		}
	}

	if (getStaSetP2p->p2pmanaged_flag == 1) {
		if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
			ret = set_supplicant_p2pmanaged(mrvl_WS_info->p2p_ctrl_interface,getStaSetP2p->p2pmanaged);
		} else if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
			/** TODO */
		}
	}
	
	if (getStaSetP2p->noa_duration_flag == 1 && getStaSetP2p->noa_interval_flag == 1 && getStaSetP2p->noa_count_flag == 1) {		
		ret = set_noa_interval(mrvl_dut_info->p2p_interface,getStaSetP2p->noa_count,getStaSetP2p->noa_duration,getStaSetP2p->noa_interval);		
	}
	
	if (getStaSetP2p->ext_listen_time_int_flag == 1 && getStaSetP2p->ext_listen_time_period_flag == 1) {
		if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
			ret = set_supplicant_ext_listen(mrvl_WS_info->p2p_ctrl_interface,getStaSetP2p->ext_listen_time_period,getStaSetP2p->ext_listen_time_int);
		} else if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
			/** TODO */
		}
	}

	if (getStaSetP2p->concurrency == 1) {
		if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
			/** TODO */
		} else if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
			runtime_test_data->devCapability |= (0x01 << 2);
		}
	}
	
	if (getStaSetP2p->p2p_mode_flag == 1) {
		if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
			ret = set_supplicant_p2p_mode(mrvl_WS_info->p2p_ctrl_interface,getStaSetP2p->p2p_mode);
		} else if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
			/** TODO */
		}
        }

	if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
		ret = set_mwud_wifidirect_capabilities(mrvl_dut_info->p2p_interface);
		ret = start_mwud_discover(mrvl_dut_info->p2p_interface);		
	}
	
    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_P2P_SETP2P_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
    LEAVE( __func__ );
    return WFA_SUCCESS;
}


/*
 * wfaStaP2pConnect():
 */
int wfaStaP2pConnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaP2pConnect_t *getStaP2pConnect = (caStaP2pConnect_t *)caCmdBuf;
	ENTER ( __func__ );
	int ret,cnt=0; 
	
	if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
		ret = set_supplicant_p2p_mode(mrvl_WS_info->p2p_ctrl_interface,"discover");
		ret = set_supplicant_p2p_wps(mrvl_WS_info->p2p_ctrl_interface,getStaP2pConnect->devId,runtime_test_data->wps_method,runtime_test_data->wps_pin);
		update_virtual_interface();
		while (cnt<10) {
			sleep(2);
			if ( check_wlan_connectivity(mrvl_WS_info->p2p_interface)  == TRUE ) {
				invoke_dhcp_client(mrvl_WS_info->p2p_interface,1);
				break;
			}
			cnt++;
		}

	} else {
		/** Special case for 5.1.4 and 7.1.4 */
		if (strstr(getStaP2pConnect->grpid,"5.1.4")) {
			runtime_test_data->oper_chn = 3;
			runtime_test_data->listen_chn = 6;
		}
		if (strstr(getStaP2pConnect->grpid,"7.1.4")) {
			runtime_test_data->oper_chn = 1;
			runtime_test_data->listen_chn = 6;
		}
		ret = init_mwud_wifidirect(mrvl_dut_info->p2p_interface,runtime_test_data->oper_chn,runtime_test_data->listen_chn,DEFAULT_INTENT,mrvl_dut_info->config_methods);
		ret = start_mwud_discover(mrvl_dut_info->p2p_interface);
		ret = init_mwud_grp_pd_request(mrvl_dut_info->p2p_interface,getStaP2pConnect->devId);
		ret = init_mwud_wps_enrollee(mrvl_dut_info->p2p_interface,getStaP2pConnect->devId);
		if ( ret != TRUE ) {
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_P2P_CONNECT_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
			LEAVE( __func__ );
			return FALSE;
		}
		invoke_dhcp_client(mrvl_dut_info->p2p_interface,1);
	}
		
	sprintf(gCmdStr,"%s %s",strtok(getStaP2pConnect->grpid, " "),strtok(getStaP2pConnect->grpid, "\0"));
	strcpy(infoResp.cmdru.grpid, gCmdStr);
	
    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_P2P_CONNECT_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
    return TRUE;
}

/*
 * wfaStaStartAutoGo(): 
 */
int wfaStaStartAutoGo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaStartAutoGo_t *getStaStartAutoGo = (caStaStartAutoGo_t *)caCmdBuf;
	int ret;
	ENTER( __func__ );
	
	if (!getStaStartAutoGo->oper_chn) {
        getStaStartAutoGo->oper_chn = DEFAULT_CHAN;
    } 
	
	if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
		ret = enable_supplicant_p2p_go(mrvl_WS_info->p2p_ctrl_interface,getStaStartAutoGo->ssid,getStaStartAutoGo->oper_chn);
		if ( ret != TRUE ) {
			printf("No active network. P2p error??\n");
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_P2P_START_AUTO_GO_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
			*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
			LEAVE ( __func__ );
			return FALSE;
		}
		// Fix 4.1.4
		if (!strcasecmp(SIGMA_PROG_NAME,MRVL_WFD_PROG)) {
			preset_wfd( mrvl_WS_info->p2p_ctrl_interface );
		}
		ret = get_supplicant_p2p_groupid(mrvl_WS_info->p2p_ctrl_interface,infoResp.cmdru.grpid);
		
	} else if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
		runtime_test_data->oper_chn =getStaStartAutoGo->oper_chn;
		if(!strcmp(getStaStartAutoGo->ssid,"6.1.1"))
			runtime_test_data->listen_chn=6;		
		ret = init_mwud_wifidirect(mrvl_dut_info->p2p_interface,runtime_test_data->oper_chn,runtime_test_data->listen_chn,DEFAULT_INTENT,mrvl_dut_info->config_methods);
		
		if (strstr(getStaStartAutoGo->ssid, "6.1") != NULL) {
		   printf ("\nDisable concurrency...");
		   runtime_test_data->devCapability = runtime_test_data->devCapability & ~(0x01 << 2);
		   set_mwud_wifidirect_capabilities(mrvl_dut_info->p2p_interface);
		}
		ret = start_mwud_autogo(mrvl_dut_info->p2p_interface,getStaStartAutoGo->ssid);
		sprintf(infoResp.cmdru.grpid,"%s DIRECT-xy%s",mrvl_dut_info->p2p_dev_address,getStaStartAutoGo->ssid);
	}

	/** Special Case 1 */
	if ( strstr(getStaStartAutoGo->ssid,"6.1.11") || strstr(getStaStartAutoGo->ssid,"6.1.12") ) {
		ret = configure_mlan_ageout_timer(mrvl_dut_info->p2p_interface,1800);
	}
	
	launch_dhcp_server(mrvl_WS_info->p2p_interface);	
	runtime_test_data->autogo =1;
	strcpy(runtime_test_data->ssid,getStaStartAutoGo->ssid);
	
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_START_AUTO_GO_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE ( __func__ );
	return TRUE;	
}
 
/*
 * wfaStaP2pStartGrpFormation(): 
 */
int wfaStaP2pStartGrpFormation(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaP2pStartGrpForm_t *getStaP2pStartGrpForm = (caStaP2pStartGrpForm_t *)caCmdBuf;
	ENTER( __func__ );
	
	char bssid[32] 	= {0};
	char  ssid[32] 	= {0};
	char grpId[64] 	= {0};
	char   role[8]  = {0};
	int ret,freq; 
	
	strcpy(infoResp.cmdru.grpFormInfo.result,"");
    strcpy(infoResp.cmdru.grpFormInfo.grpId,"");
	
	/** Initialize Operating Channel if channel value is zero... */
	if (!getStaP2pStartGrpForm -> oper_chn) {
		getStaP2pStartGrpForm -> oper_chn = 36;
	}
	runtime_test_data->oper_chn = getStaP2pStartGrpForm -> oper_chn;
	freq = channel_to_frequency(getStaP2pStartGrpForm -> oper_chn);
	
	if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
		ret = init_mwud_wifidirect(mrvl_dut_info->p2p_interface,runtime_test_data->oper_chn,runtime_test_data->listen_chn,getStaP2pStartGrpForm ->intent_val,mrvl_dut_info->config_methods);
		ret = start_mwud_discover(mrvl_dut_info->p2p_interface);		
	}
	
    if (getStaP2pStartGrpForm->init_go_neg == 1) {
		if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
			/** Supplicant */ 
			ret = supplicant_initiate_p2p_negotiation(mrvl_WS_info->p2p_ctrl_interface,getStaP2pStartGrpForm->devId,getStaP2pStartGrpForm ->intent_val,freq,runtime_test_data->wps_method,runtime_test_data->wps_pin);
			
			if ( ret != TRUE ) {
				printf("No active network. P2p error??\n");
				infoResp.status = STATUS_COMPLETE;
				wfaEncodeTLV(WFA_STA_P2P_START_GRP_FORMATION_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
				*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);	
				LEAVE ( __func__ );
				return FALSE;
			}
			
			ret = fetch_active_network_info(mrvl_WS_info->p2p_ctrl_interface,mrvl_WS_info->network_index,ssid,bssid);
			get_supplicant_p2p_groupid(mrvl_WS_info->p2p_ctrl_interface,grpId);	
			strcpy(infoResp.cmdru.grpFormInfo.grpId,grpId);
			
			if (!strncmp(bssid, "FAIL", 4)) {
				strcpy(infoResp.cmdru.grpFormInfo.result,"GO");
				launch_dhcp_server(mrvl_WS_info->p2p_interface);
				strcpy(runtime_test_data->neg_res,"GO");
			} else {
				strcpy(infoResp.cmdru.grpFormInfo.result,"CLIENT");
				invoke_dhcp_client(mrvl_WS_info->p2p_interface,1);
				strcpy(runtime_test_data->neg_res,"CLIENT");
			}
		} else {
			/** MWUD */
			ret = init_mwud_grp_negotiation(mrvl_dut_info->p2p_interface,getStaP2pStartGrpForm->devId,role);	
			if ( ret != TRUE ) {
				infoResp.status = STATUS_ERROR;
				wfaEncodeTLV(WFA_STA_P2P_START_GRP_FORMATION_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
				*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);	
				LEAVE ( __func__ );
				return FALSE;
			}
			if ( !strcmp(role,"GO")) {
				ret= start_mwud_go(mrvl_dut_info->p2p_interface,runtime_test_data->ssid);
				launch_dhcp_server(mrvl_dut_info->p2p_interface);
				strcpy(infoResp.cmdru.grpFormInfo.result,"GO");
				sprintf(infoResp.cmdru.grpFormInfo.grpId,"%s %s",infoResp.cmdru.devid,runtime_test_data->ssid);
				
			} else if (!strcmp(role,"CLIENT")) {
				init_mwud_wps_enrollee(mrvl_dut_info->p2p_interface,getStaP2pStartGrpForm->devId);
				strcpy(infoResp.cmdru.grpFormInfo.result,"CLIENT");
				sprintf(infoResp.cmdru.grpFormInfo.grpId,"%s %s",getStaP2pStartGrpForm->devId,runtime_test_data->ssid);
				invoke_dhcp_client(mrvl_dut_info->p2p_interface,1);		
			}	
		}
	} else {
		if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
			/** Supplicant */
			if (!strcmp(runtime_test_data->wps_method,ENTER_WPS_PIN)) {
				ret = supplicant_initiate_p2p_negotiation(mrvl_WS_info->p2p_ctrl_interface,getStaP2pStartGrpForm->devId,getStaP2pStartGrpForm ->intent_val,freq,runtime_test_data->wps_method,runtime_test_data->wps_pin);
			} else {
				/** Run in child thread */ 
				init_p2p_connect_thread(mrvl_WS_info->p2p_ctrl_interface,getStaP2pStartGrpForm->devId,getStaP2pStartGrpForm ->intent_val,freq,runtime_test_data->wps_method,runtime_test_data->wps_pin);
			}
		} else {
			/** MWUD */
			ret = allow_peers_connections(mrvl_WS_info->p2p_ctrl_interface,getStaP2pStartGrpForm->devId);
			pid_t pid;
			pid=fork();
			if( pid == 0) {
				init_mwud_wps_enrollee(mrvl_dut_info->p2p_interface,getStaP2pStartGrpForm->devId);
			}
		}
	}
	
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_START_GRP_FORMATION_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE ( __func__ );
	return TRUE;
}

/*
 * wfaStaP2pDissolve(): 
 */
int wfaStaP2pDissolve(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
	caStaP2pDissolve_t *getStap2pDissolve= (caStaP2pDissolve_t *)caCmdBuf;
	ENTER( __func__ );
    
	if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
		if (runtime_test_data->autogo || !strcmp(runtime_test_data->neg_res,"CLIENT")) {
			sprintf(gCmdStr, "%s/%s -i %s p2p_group_remove %s",APP_BIN_LOC, mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->p2p_ctrl_interface,mrvl_WS_info->p2p_interface);   
		} else {
			sprintf(gCmdStr, "%s/%s -i %s p2p_flush",APP_BIN_LOC,mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->p2p_ctrl_interface);
		}
		system_with_log(gCmdStr);
		update_virtual_interface();
	} else {
		/** MWUD */
	}

    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_P2P_DISSOLVE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE ( __func__ );
	return TRUE;
}

/*
 * wfaStaSendP2pInvReq(): 
 */
int wfaStaSendP2pInvReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaSendP2pInvReq_t *getStaP2pInvReq= (caStaSendP2pInvReq_t *)caCmdBuf;
	ENTER( __func__ );
	int ret; 

	if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
		if (!getStaP2pInvReq->reinvoke) {
			ret = invoke_sendInvReq(mrvl_WS_info->p2p_ctrl_interface,getStaP2pInvReq->devId);
		} else {
			ret = reinvoke_sendInvReq(mrvl_WS_info->p2p_ctrl_interface,getStaP2pInvReq->devId);
			if (!strcmp(runtime_test_data->neg_res,"GO")) {
				update_virtual_interface();
				launch_dhcp_server(mrvl_WS_info->p2p_interface);			
			}
		}
	} else {
		/** MWUD */	
	}
	runtime_test_data->reinvoke =1;
	
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_SEND_INV_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE ( __func__ );
    return TRUE;
}

/*
 * wfaStaAcceptP2pInvReq(): 
 */
int wfaStaAcceptP2pInvReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaAcceptP2pInvReq_t *getStaP2pInvReq= (caStaAcceptP2pInvReq_t *)caCmdBuf;
	ENTER( __func__ );
	int ret;
	
	if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
		if ( !getStaP2pInvReq->reinvoke ) {
			ret = invoke_acceptInvReq(mrvl_WS_info->p2p_ctrl_interface,getStaP2pInvReq->devId);		
		} else {
			sprintf(gCmdStr, "%s/%s -i %s p2p_set disabled 0",APP_BIN_LOC,mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->p2p_ctrl_interface);
        	system_with_log(gCmdStr);
			sprintf(gCmdStr, "%s/%s -i %s p2p_listen 120",APP_BIN_LOC,mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->p2p_ctrl_interface);
			system_with_log(gCmdStr);
			if (!strcmp(runtime_test_data->neg_res,"GO")) {
				update_virtual_interface();
				launch_dhcp_server(mrvl_WS_info->p2p_interface);			
			}
		}
	} else {
		/** MWUD */	
	}
	runtime_test_data->reinvoke =1;
	
    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_P2P_ACCEPT_INV_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE ( __func__ );
    return TRUE;
}

/*
 * wfaStaSendP2pProvDisReq(): 
 */
int wfaStaSendP2pProvDisReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaSendP2pProvDisReq_t *getStaP2pProvDisReq= (caStaSendP2pProvDisReq_t *)caCmdBuf;
	ENTER( __func__ );

	/** TODO */
	
    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_P2P_SEND_PROV_DIS_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE ( __func__ );
    return TRUE;
}

/*
 * wfaStaGetP2pIpConfig(): 
 */
int wfaStaGetP2pIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaGetP2pIpConfig_t *staGetP2pIpConfig= (caStaGetP2pIpConfig_t *)caCmdBuf;   
    caStaGetIpConfigResp_t *ifinfo = &(infoResp.cmdru.getIfconfig);
	memset(ifinfo,0,sizeof(caStaGetIpConfigResp_t));
	ENTER( __func__ );

	if ( runtime_test_data->reinvoke && !strcmp(runtime_test_data->neg_res,"CLIENT") && !runtime_test_data->autogo) {
		update_virtual_interface();
		invoke_dhcp_client(mrvl_WS_info->p2p_interface,1);
	}
	
    int slen, ret, i = 0;
    FILE *tmpfd;
    char string[128];
    char *str;
	
    sprintf(gCmdStr,"getipconfig.sh");
    ret = access(gCmdStr, F_OK);
    if(ret == -1) {
        infoResp.status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_P2P_GET_IP_CONFIG_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
        *respLen = WFA_TLV_HDR_LEN + 4;
        DPRINT_ERR(WFA_ERR, "file not exist\n");
		LEAVE ( __func__ );
		return FALSE; 
    }

    strcpy(ifinfo->dns[0], "0");
    strcpy(ifinfo->dns[1], "0");
    
	if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
		sprintf(gCmdStr, "%s sh %s/getipconfig.sh /tmp/ipconfig.txt %s\n",DUT_CMD_PREFIX,APP_BIN_LOC,mrvl_WS_info->p2p_interface);
	} else {
		sprintf(gCmdStr, "%s sh %s/getipconfig.sh /tmp/ipconfig.txt %s\n",DUT_CMD_PREFIX,APP_BIN_LOC,mrvl_dut_info->p2p_interface);	
	}
	system_with_log(gCmdStr);

    /** Open the output result and scan/retrieve the info */
    tmpfd = fopen("/tmp/ipconfig.txt", "r+");
    sprintf(gCmdStr, "%s cat /tmp/ipconfig.txt\n",DUT_CMD_PREFIX); 
    system_with_log(gCmdStr);
    if(tmpfd == NULL) {
        infoResp.status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_P2P_GET_IP_CONFIG_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
        *respLen = WFA_TLV_HDR_LEN + 4;
        DPRINT_ERR(WFA_ERR, "/tmp/ipconfig.txt file not exist\n");
		LEAVE ( __func__ );
        return FALSE; 
    }
    
    for(;;)
    {
        if(fgets(string, 128, tmpfd) == NULL)
        break; 
	
		/** Check dhcp enabled */
        if(strncmp(string, "dhcpcli", 7) ==0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, "=");
            if(str != NULL)
               ifinfo->isDhcp = 1;
            else
               ifinfo->isDhcp = 0;
        }

        /** Check the mac */
        if(strncmp(string, "mac", 3) == 0)
        {
            str = strtok(string, " ");
            printf ("\n str1 = %s\n", str);
            str = strtok(NULL, " ");
            printf ("\n str2 = %s\n", str);
            if(str != NULL)
            {
               strncpy(ifinfo->mac, str, 17);
               ifinfo->mac[17] = '\0';
            }
            else
            strcpy(ifinfo->mac, "00:00:00:00:00:00");
        }

        /** Find out the ip address */
        if(strncmp(string, "ipaddr", 6) == 0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, " ");
            if(str != NULL)
            {
               strncpy(ifinfo->ipaddr, str, 15);
               ifinfo->ipaddr[15]='\0';
            }
            else
            strncpy(ifinfo->ipaddr, "000.000.000.000", 15);
        }

        /** Check the mask */
        if(strncmp(string, "mask", 4) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;

            str = strtok_r(string, "=", &ttp);
            if(*ttp != '\0')
            {
               strcpy(ifinfo->mask, ttp);
               slen = strlen(ifinfo->mask);
               ifinfo->mask[slen-1] = '\0';
            }
            else
            strcpy(ifinfo->mask, "255.255.255.255");
        }

        /** Find out the dns server ip address */
        if(strncmp(string, "nameserv", 8) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;
            
            str = strtok_r(string, " ", &ttp);
            if(str != NULL && i < 2)
            {
               strcpy(ifinfo->dns[i], ttp);
               slen = strlen(ifinfo->dns[i]);
               ifinfo->dns[i][slen-1] = '\0';
            }
            i++;
        }   
    }
	
	fclose(tmpfd);
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_GET_IP_CONFIG_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
    LEAVE ( __func__ );
	return TRUE;
}

/*
 * wfaStaSendServiceDiscoveryReq(): 
 */
int wfaStaSendServiceDiscoveryReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaSendServiceDiscoveryReq_t *staSendServiceDiscoveryReq= (caStaSendServiceDiscoveryReq_t *)caCmdBuf; 
	ENTER ( __func__ );
   
	if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
		sprintf(gCmdStr,"%s/%s -i %s p2p_serv_disc_req %s 02000001",APP_BIN_LOC,mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->p2p_ctrl_interface,staSendServiceDiscoveryReq->devId);
		system_with_log(gCmdStr);
	} else {
		/** MWUD */
	}
	
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_SEND_SERVICE_DISCOVERY_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE ( __func__ );
	return TRUE;
}

/*
 * wfaStaSendP2pPresenceReq(): 
 */
int wfaStaSendP2pPresenceReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaSendP2pPresenceReq_t *staSendP2pPresenceReq= (caStaSendP2pPresenceReq_t *)caCmdBuf;
	ENTER ( __func__ );

	printf("\n The long long Duration: %lld... ",staSendP2pPresenceReq->duration);
	printf("\n The long long interval : %lld.. ",staSendP2pPresenceReq->interval);

	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_SEND_PRESENCE_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE ( __func__ );
	return TRUE;
}

/*
 * wfaStaSetSleepReq(): 
 */
int wfaStaSetSleepReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaSetSleep_t *staSetSleepReq= (caStaSetSleep_t *)caCmdBuf;
	ENTER ( __func__ );
	
	if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_P2P_PROG) || !strcasecmp(SIGMA_PROG_NAME,MRVL_WFD_PROG) ) {
		configure_powersave_mode(mrvl_dut_info->p2p_interface,1);
	} else {
		configure_powersave_mode(mrvl_dut_info->sta_interface,1);	
	}
	
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_SET_SLEEP_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN +4;
	LEAVE ( __func__ );
	return TRUE;
}

/*
 * wfaStaSetOpportunisticPsReq(): 
 */
int wfaStaSetOpportunisticPsReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaSetOpprPs_t *staSetOpperPsReq= (caStaSetOpprPs_t *)caCmdBuf;
	ENTER ( __func__ );
	char *ifname;
	int ret; 
	
	if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_P2P_PROG) || !strcasecmp(SIGMA_PROG_NAME,MRVL_WFD_PROG) ) {
		ifname = mrvl_WS_info->p2p_interface;
	} else {
		ifname = mrvl_dut_info->p2p_interface;	
	}
	ret = configure_OpportunisticPowerSave(ifname,staSetOpperPsReq->ctwindow);
	
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_SET_OPPORTUNISTIC_PS_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE ( __func__ );
	return TRUE;
}

#ifndef WFA_STA_TB
/*
 * wfaStaPresetParams(): 
 */

int wfaStaPresetParams(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaPresetParameters_t *presetParams = (caStaPresetParameters_t *)caCmdBuf;
	ENTER ( __func__ );


	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)&infoResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE ( __func__ );
	return TRUE;
}
#endif

int wfaStaSet11n(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf) 
{
	
	caSta11n_t * v11nParams = (caSta11n_t *)caCmdBuf;
	dutCmdResponse_t infoResp;
	dutCmdResponse_t *v11nParamsResp = &infoResp;
	ENTER ( __func__ );
	
	int st =0; 
	
	
	if(v11nParams->addba_reject != 0xFF && v11nParams->addba_reject < 2)
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_addba_reject failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}
	
    if(v11nParams->ampdu != 0xFF && v11nParams->ampdu < 2)
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_ampdu failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}
	
    if(v11nParams->amsdu != 0xFF && v11nParams->amsdu < 2)
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_amsdu failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

    if(v11nParams->greenfield != 0xFF && v11nParams->greenfield < 2)
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "_set_greenfield failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

    if(v11nParams->mcs32!= 0xFF && v11nParams->mcs32 < 2 && v11nParams->mcs_fixedrate[0] != '\0')
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_mcs failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	} 
	else if (v11nParams->mcs32!= 0xFF && v11nParams->mcs32 < 2 && v11nParams->mcs_fixedrate[0] == '\0')
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_mcs32 failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	} 
	else if (v11nParams->mcs32 == 0xFF && v11nParams->mcs_fixedrate[0] != '\0')
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_mcs32 failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

    if(v11nParams->rifs_test != 0xFF && v11nParams->rifs_test < 2)
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_rifs_test failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

    if(v11nParams->sgi20 != 0xFF && v11nParams->sgi20 < 2)
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_sgi20 failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

	if(v11nParams->smps != 0xFFFF)
	{
	    if(v11nParams->smps == 0)
	    {

	    }
	    else if(v11nParams->smps == 1)
	    {

	    }		
	    else if(v11nParams->smps == 2)
		{
		
	    }
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_smps failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

	if(v11nParams->stbc_rx != 0xFFFF)
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_stbc_rx failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}
	
	if(v11nParams->width[0] != '\0')
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_11n_channel_width failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}
	
    if(v11nParams->_40_intolerant != 0xFF && v11nParams->_40_intolerant < 2)
	{
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_40_intolerant failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

	if(v11nParams->txsp_stream != 0 && v11nParams->txsp_stream <4)
	{
		if(st != 0)
		{
			v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_txsp_stream failed");
			wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

	if(v11nParams->rxsp_stream != 0 && v11nParams->rxsp_stream < 4)
	{
		if(st != 0)
		{
			v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_rxsp_stream failed");
			wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

	v11nParamsResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, 4, (BYTE *)v11nParamsResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE ( __func__ );
	return TRUE;
}

/*
 * wfaStaAddArpTableEntry(): 
 */
int wfaStaAddArpTableEntry(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaAddARPTableEntry_t *staAddARPTableEntry= (caStaAddARPTableEntry_t *)caCmdBuf;
	ENTER ( __func__ );


	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_ADD_ARP_TABLE_ENTRY_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE ( __func__ );
	return TRUE;
}

/*
 * wfaStaBlockICMPResponse(): 
 */
int wfaStaBlockICMPResponse(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaBlockICMPResponse_t *staAddARPTableEntry= (caStaBlockICMPResponse_t *)caCmdBuf;
	ENTER ( __func__ );

	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_BLOCK_ICMP_RESPONSE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE ( __func__ );
	return TRUE;
}

int wfaStaSetRadio(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	ENTER ( __func__ );
    dutCommand_t *setRadio = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *staCmdResp = &gGenericResp;
    caStaSetRadio_t *sr = &setRadio->cmdsu.sr;
	char *str;
 
    if(sr->mode == WFA_OFF)
    {
       /** turn radio off */
    }
    else
    {
       /** always turn the radio on */
    }

    staCmdResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_RADIO_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE ( __func__ );
    return WFA_SUCCESS;
}

int wfaStaSetRFeature(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaRFeat_t *rfeat = (caStaRFeat_t *)caCmdBuf;
	dutCmdResponse_t *caResp = &gGenericResp;
	ENTER( __func__ );	
	char *intf = rfeat->intf;
	char *str, *nss, *mcs_opt;
    int ret; 
	
	if(!strcasecmp(SIGMA_PROG_NAME,MRVL_MBO_PROG)) {
		if (rfeat->Cellular_Data_Cap_Flag) {
			sprintf(gCmdStr,"./%s -i%s set mbo_cell_capa %d",mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->sta_ctrl_interface,rfeat->Cellular_Data_Cap);
			system_with_log(gCmdStr);
		}
	    if (rfeat->Ch_Pref_Flag) {
            if (rfeat->Ch_Pref == 0) {
                sprintf(gCmdStr,"./%s -i%s set non_pref_chan 0",
                    mrvl_WS_info->supplicant_cli_bin,
                    mrvl_WS_info->sta_ctrl_interface);
                system_with_log(gCmdStr);
				runtime_test_data->rfeat_non_pref_chan_list[0] = '\0';
            }
        }
		if (rfeat->Ch_Op_Class_Flag) {
			sprintf(gCmdStr,"%d:%d:%d:%d ",
				    rfeat->Ch_Op_Class,
                    rfeat->Ch_Pref_Num,
					rfeat->Ch_Pref,
                    rfeat->Ch_Reason_Code);
			strcat(runtime_test_data->rfeat_non_pref_chan_list,gCmdStr);
			sprintf(gCmdStr,"./%s -i%s set non_pref_chan '%s'",
                    mrvl_WS_info->supplicant_cli_bin,
                    mrvl_WS_info->sta_ctrl_interface,
                    runtime_test_data->rfeat_non_pref_chan_list);
            system_with_log(gCmdStr);
		}
	}
	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_TDLS_PROG)) {
		ret = wfaStaSetRFeatureTDLS(len,caCmdBuf,respLen,respBuf);
	}   
	if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_VHT_PROG) ) {
		if(rfeat->nss_mcs_opt_flag == 1)  {
			
			nss = strtok(rfeat->nss_mcs_opt, ";");
			mcs_opt = strtok(NULL, "");
			
			if ( !strcasecmp(nss,"def") || !strcasecmp(mcs_opt,"def")) {
				ret = set_mlan_txrate(mrvl_dut_info->sta_interface,"","");
			} else {
				ret = set_mlan_txrate(mrvl_dut_info->sta_interface,mcs_opt,nss);
			}
			}
		}
	if (! strcasecmp(SIGMA_PROG_NAME,MRVL_HE_PROG) ) {

		printf("\nI am here in wfa_cs.c for sta_set_rfeature  \n\r\n");
		
		printf("\nThe Band selected is \n\r 24G=%d\n\r5G=%d \n\r\n",rfeat->HE_BAND_24G,rfeat->HE_BAND_5G);


	if ((rfeat->LTF_Flag == 1) && (rfeat->GI_Flag == 1))	
	{
		{if (rfeat->HE_BAND_24G==1)
		     {   rfeat->HE_BAND_5G=0; 

		 if (!(strcasecmp((rfeat->LTF),"6.4")) && (!(strcasecmp((rfeat->GI),"0.8"))))
			{printf("\n Enter command for LTF-6.4 and GI-0.8\n\r");
	    		 sprintf(gCmdStr, "%s/%s %s txratecfg 3 7 2 0x2020", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
        		  system_with_log(gCmdStr);
			 ret = 1;
			}
		
		 if (!(strcasecmp((rfeat->LTF),"6.4")) && (!(strcasecmp((rfeat->GI),"1.6"))))
			{printf("\n Enter command for LTF-6.4 and GI-1.6\n\r");
	    		 sprintf(gCmdStr, "%s/%s %s txratecfg 3 7 2 0x2040", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
        		  system_with_log(gCmdStr);
			 ret = 1;
			}

		
		 if (!(strcasecmp((rfeat->LTF),"12.8")) && (!(strcasecmp((rfeat->GI),"3.2"))))
			{printf("\n Enter command for LTF-12.8 and GI-3.2\n\r");
	    		 sprintf(gCmdStr, "%s/%s %s txratecfg 3 7 2 0x2060", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
        		  system_with_log(gCmdStr);
			 ret = 1;
			}
			}
		}
	
		{ if (rfeat->HE_BAND_5G==1)
			{	rfeat->HE_BAND_24G=0; 

		 if (!(strcasecmp((rfeat->LTF),"6.4")) && (!(strcasecmp((rfeat->GI),"0.8"))))
			{printf("\n Enter command for LTF-6.4 and GI-0.8\n\r");
	    		 sprintf(gCmdStr, "%s/%s %s txratecfg 3 7 2 0x2228", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
        		  system_with_log(gCmdStr);
			 ret = 1;
		 	}
		
		 if (!(strcasecmp((rfeat->LTF),"6.4")) && (!(strcasecmp((rfeat->GI),"1.6"))))
			{printf("\n Enter command for LTF-6.4 and GI-1.6\n\r");
	    		 sprintf(gCmdStr, "%s/%s %s txratecfg 3 7 2 0x2248", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
        		  system_with_log(gCmdStr);
			 ret = 1;
			}

		
		 if (!(strcasecmp((rfeat->LTF),"12.8")) && (!(strcasecmp((rfeat->GI),"3.2"))))
			{printf("\n Enter command for LTF-12.8 and GI-3.2\n\r");
	    		 sprintf(gCmdStr, "%s/%s %s txratecfg 3 7 2 0x2268", APP_BIN_LOC,MLANUTL,mrvl_dut_info->sta_interface);
        		  system_with_log(gCmdStr);
			 ret = 1;
			}

			}
		}
		}
	
	if (rfeat->TWT_Setup_Flag == 1)	
		{ printf("\nRUN TWT COMMANDS\n\r\n");
	//DPRINT_INFO(WFA_OUT," \n RFEATURE command for HE TWT\r\n");
		ret = 1;
		}
	if (rfeat->transmitOMI_Flag == 1)	
		{ printf("\nRUN OMI COMMANDS\n\r\n");
	// DPRINT_INFO(WFA_OUT," \n RFEATURE command for HE OMC \r\n");
		ret = 1;
		}

		}
	caResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_RFEATURE_RESP_TLV, 4, (BYTE *)caResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
	return WFA_SUCCESS;
}


int wfaStaExecAction(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaExecAction_t *execAction= (caStaExecAction_t *)caCmdBuf;
    dutCmdResponse_t *execActionResp = &gGenericResp;
	int ret;
		
	ENTER( __func__ );
	printf ("Interface = %s\n",execAction->intf);
	printf ("Dest Mac = %s\n",execAction->destmac);
	printf ("Trigger =%s\n",execAction->trigger);
	printf ("BurstsExponent =%d\n",execAction->BurstsExponent);
	printf ("asap =%d\n",execAction->asap);
	printf ("FormatBwFTM =%d\n",execAction->FormatBwFTM);
	printf ("askForLocCivic =%d\n",execAction->askForLocCivic);
	printf ("askForLCI =%d\n",execAction->askForLCI);


		
    execActionResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_EXEC_ACTION_RESP_TLV, 4, (BYTE *)execActionResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return TRUE;
}


/*
 * This is used to send a frame or action frame
 */
int wfaStaDevSendFrame(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   	dutCommand_t *cmd = (dutCommand_t *)caCmdBuf;
   	dutCmdResponse_t *devSendResp = &gGenericResp;
   	caStaDevSendFrame_t *sf = &cmd->cmdsu.sf;
	int ret; 
	FILE *fp; 
	
	ENTER( __func__ );
	switch(sf->program){
	  case PROG_TYPE_MBO:
	   {
			MBO_Frame_t *mbo = &sf->frameType.mbo;
			char list[8]= {0}; 
			if ( mbo->cand_list ) 
				strcpy(list,"list");
			if (mbo->BTMQuery) {
				sprintf(gCmdStr,"./%s -i%s wnm_bss_query %d %s",mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->sta_ctrl_interface,mbo->BTMQuery_Reason_Code,list);
				system_with_log(gCmdStr);	
			}
			if (mbo->BTMReq) {
			}
			if (mbo->BcnRptReq) {
			}
			if (mbo->WNM_Notify) {
	if (strlen(runtime_test_data->rfeat_non_pref_chan_list)) {
                    sprintf(gCmdStr,"./%s -i%s set non_pref_chan '%s'",mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->sta_ctrl_interface,runtime_test_data->rfeat_non_pref_chan_list);
                    system_with_log(gCmdStr);
                }	
			}	
	
			if (mbo->ANQPQuery) {						
				if (mbo->NeighborReportReq) {
					sprintf(gCmdStr,"./%s -i%s anqp_get %s 272",mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->sta_ctrl_interface,mbo->dest);
					system_with_log(gCmdStr);	
				} else if (mbo->QueryListWithCellPref) {
					sprintf(gCmdStr,"./%s -i%s anqp_get %s 272,mbo:2",mrvl_WS_info->supplicant_cli_bin,mrvl_WS_info->sta_ctrl_interface,mbo->dest);
					system_with_log(gCmdStr);	
				}
			}
	   }	
       case PROG_TYPE_PMF:
       {
          pmfFrame_t *pmf = &sf->frameType.pmf;
          switch(pmf->eFrameName)
          {
              case PMF_TYPE_DISASSOC:
              {
             
              }
              break;
              case PMF_TYPE_DEAUTH:
              {

              }
              break;
              case PMF_TYPE_SAQUERY:
              {

              }
              break;
              case PMF_TYPE_AUTH:
              {
              }
              break;
              case PMF_TYPE_ASSOCREQ:
              {
              }
              break;
              case PMF_TYPE_REASSOCREQ:
              {
              }
              break;
          }
       }
       break;
       case PROG_TYPE_TDLS:
       {
          tdlsFrame_t *tdls = &sf->frameType.tdls;
          switch(tdls->eFrameName) {
			case TDLS_TYPE_DISCOVERY:
			ret = send_WS_tdls_frame(mrvl_WS_info->sta_ctrl_interface,TDLS_TYPE_DISCOVERY,tdls->peer);		
			break;
			case TDLS_TYPE_SETUP:
			ret = send_WS_tdls_frame(mrvl_WS_info->sta_ctrl_interface,TDLS_TYPE_SETUP,tdls->peer);
			break;
			case TDLS_TYPE_TEARDOWN:
			ret = send_WS_tdls_frame(mrvl_WS_info->sta_ctrl_interface,TDLS_TYPE_TEARDOWN,tdls->peer);
			break;
			case TDLS_TYPE_CHANNELSWITCH:
			ret = send_mlan_tdls_cs_frame(mrvl_dut_info->sta_interface,tdls->peer,tdls->channel,tdls->offset[0],tdls->switchtime);	
			break;
			case TDLS_TYPE_NULLFRAME:
			break;
		  }
	   }
       break;
       case PROG_TYPE_VENT:
       {
          ventFrame_t *vent = &sf->frameType.vent;
          switch(vent->type)
          {
              case VENT_TYPE_NEIGREQ:
              break;
              case VENT_TYPE_TRANSMGMT:
              break;
          }
       } 
       case PROG_TYPE_WFD:
       {
          wfdFrame_t *wfd = &sf->frameType.wfd;
          switch(wfd->eframe)
          {
              case WFD_FRAME_PRBREQ:
              {
                /** send probe req */
                // Fix 4.1.1
                ret = set_supplicant_p2p_mode(mrvl_WS_info->p2p_ctrl_interface,"discover");
              }
              break;

              case WFD_FRAME_PRBREQ_TDLS_REQ:
              {
                /** send tunneled tdls probe req  */
              }
              break;

              case WFD_FRAME_11V_TIMING_MSR_REQ:
              {
				/** send 11v timing measurement request */
              }
              break;

              case WFD_FRAME_RTSP:
              {
                /** send WFD RTSP messages 
					fetch the type of RTSP message and send it. */
                    switch(wfd->eRtspMsgType) {
						case WFD_RTSP_PAUSE:
				      
						break;
						case WFD_RTSP_PLAY:
												
						break;
						case WFD_RTSP_TEARDOWN:
			         
						break;
						case WFD_RTSP_TRIG_PAUSE:
						
						break;
						case WFD_RTSP_TRIG_PLAY:
						
						break;
						case WFD_RTSP_TRIG_TEARDOWN:
            
						break;
						case WFD_RTSP_SET_PARAMETER:
						if (wfd->eSetParams == WFD_CAP_UIBC_KEYBOARD) {
                         /** send RTSP SET PARAMETER message for UIBC keyboard */
						}
						if (wfd->eSetParams == WFD_CAP_UIBC_MOUSE) {
                         /** send RTSP SET PARAMETER message for UIBC Mouse */
						} else if (wfd->eSetParams == WFD_CAP_RE_NEGO) {
                         /** send RTSP SET PARAMETER message Capability re-negotiation */
						} else if (wfd->eSetParams == WFD_STANDBY) {
                         /** send RTSP SET PARAMETER message for standby */
						} else if (wfd->eSetParams == WFD_UIBC_SETTINGS_ENABLE) {
                         /** send RTSP SET PARAMETER message for UIBC settings enable */
						} else if (wfd->eSetParams == WFD_UIBC_SETTINGS_DISABLE) {
                         /** send RTSP SET PARAMETER message for UIBC settings disable */
						} else if (wfd->eSetParams == WFD_ROUTE_AUDIO) {
                         /** send RTSP SET PARAMETER message for route audio */
						} else if (wfd->eSetParams == WFD_3D_VIDEOPARAM) {
                         /** send RTSP SET PARAMETER message for 3D video parameters */
						} else if (wfd->eSetParams == WFD_2D_VIDEOPARAM) {
                         /** send RTSP SET PARAMETER message for 2D video parameters */
						}						
						break;		
					}
				}
              break;
			}
		}	 
       case PROG_TYPE_VHT5G:
       {
		vht5gFrame_t *vht5g = &sf->frameType.vht5g;
		if (strcasecmp(vht5g->frameName, "Op_md_notif_frm") == 0) {
			int width = vht5g->para.opt_md.channel_width;
			int nss = vht5g->para.opt_md.nss;
			set_vht_nss_config(mrvl_dut_info->sta_interface,nss,width);	
		}
		break;
       }
	   	   
       case PROG_TYPE_GEN:
       {
		/** General frames */
       }

	   case PROG_TYPE_HS2: 
	   {

	   		HS2_Frame_t *hs2 = &sf->frameType.hs2;  		  
			if (hs2->ARPREPLY == 1) {
				sprintf(gCmdStr, "arping  -i %s -H -S %s -t %s  %s -c 5 -D > /tmp/pingResult.txt ",mrvl_dut_info->sta_interface,hs2->srcip,hs2->dest,hs2->destip);
				system_with_log(gCmdStr);
			}	
			else if (hs2->DLSrequest){
				DPRINT_INFO(WFA_OUT,"HS2 DLSrequest :%d",hs2->DLSrequest);
			}
        	else if (hs2->neighSolicitReq) {
            	char ipv6addr[WFA_IP_V6_ADDR_STR_LEN];
				ret = fetch_ipv6_info(mrvl_dut_info->sta_interface,ipv6addr);
				ret = reassign_ipv6_addr(mrvl_dut_info->sta_interface,ipv6addr);
		    }	
		    else if (hs2->arpProbe) {
		        char ipv4addr[16] = {0};
				ret = fetch_ipv4_info(mrvl_dut_info->sta_interface,ipv4addr);	
				sprintf(gCmdStr, "arping -i %s -s %s -S 0.0.0.0 -t ff:ff:ff:ff:ff:ff %s -c 3 -D -U", mrvl_dut_info->sta_interface, hs2->srcmac, ipv4addr);
		        system_with_log(gCmdStr);
		    }
		    else if (hs2->arpAnnounce) {
		        char ipv4addr[16];
				ret = fetch_ipv4_info(mrvl_dut_info->sta_interface,ipv4addr);
		        sprintf(gCmdStr, "arping -i %s -s %s -S %s -t ff:ff:ff:ff:ff:ff %s -c 3 -D -U",mrvl_dut_info->sta_interface, hs2->srcmac, ipv4addr, ipv4addr);
		        system_with_log(gCmdStr);
		    } else {  	
				if ( mrvl_dut_info->use_supplicant ) {
					char ANQP_LIST[128];
					char HS20_ANQP_LIST[128];	
					
					strcpy(ANQP_LIST,"");
					if (hs2->anqpCapList) 					
						sprintf(ANQP_LIST,"%s%s,",ANQP_LIST,MASK_CAPA_LIST);		
					if (hs2->nairealmlist) 
						sprintf(ANQP_LIST,"%s%s,",ANQP_LIST,MASK_NAI_REALM);
					if (hs2->domainlist) 
						sprintf(ANQP_LIST,"%s%s,",ANQP_LIST,MASK_DOMAIN_INFO);					
					if (hs2->g3ppinfo)
						sprintf(ANQP_LIST,"%s%s,",ANQP_LIST,MASK_3GPP_NETWORK);
					if (hs2->venuename)	
						sprintf(ANQP_LIST,"%s%s,",ANQP_LIST,MASK_VENUE_NAME);					
					if (strlen(ANQP_LIST)) 
						ANQP_LIST[strlen(ANQP_LIST) -1] = '\0';
						
					strcpy(HS20_ANQP_LIST,"");
					if (hs2->hscaplist)
						sprintf(HS20_ANQP_LIST,"%s%s,",HS20_ANQP_LIST,MASK_WIFI_HS_CAPA_LIST);				
					if (hs2->opername)
						sprintf(HS20_ANQP_LIST,"%s%s,",HS20_ANQP_LIST,MASK_WIFI_HS_OP_FRIENDLY_NAME);			
					if (hs2->wanmat)
						sprintf(HS20_ANQP_LIST,"%s%s,",HS20_ANQP_LIST,MASK_WIFI_HS_WAN_METRICS);			
					if (hs2->opclass)
						sprintf(HS20_ANQP_LIST,"%s%s,",HS20_ANQP_LIST,MASK_WIFI_HS_OP_CLASS_IND);
					if (hs2->osuProviderlist) 	
						sprintf(HS20_ANQP_LIST,"%s%s,",HS20_ANQP_LIST,MASK_WIFI_HS_OSU);
					if (strlen(HS20_ANQP_LIST)) 
						HS20_ANQP_LIST[strlen(HS20_ANQP_LIST) -1] = '\0';
					ret = configure_supplicant_hs2_anqp(mrvl_WS_info->sta_ctrl_interface,ANQP_LIST,HS20_ANQP_LIST,hs2->dest);				
				
					/** Special Cases */											
					if (hs2->naihomerealmlist) 
						ret = configure_hs2_homerealmlist(mrvl_WS_info->sta_ctrl_interface,hs2->dest);
					if (hs2->iconRequestList) 
						ret = configure_hs2_iconrequest(mrvl_WS_info->sta_ctrl_interface,hs2->dest,hs2->iconRequest);
					
				} else {
					/** Not Supported */
				}   
			}
	   }
/*	   case PROG_TYPE_WLS: 
	   {
		   WLS_Frame_t *wls = &sf->frameType.wls;  
		   printf("%s\n",wls->intf);
		   printf("%s\n",wls->destmac);
		   printf("%s\n",wls->framename);
		   printf("%d\n",wls->MsntType);
		   printf("%d\n",wls->AskForPublicIdentifierURI_FQDN);
		   	    
	   }
*/	   
   }
   devSendResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_DEV_SEND_FRAME_RESP_TLV, 4, (BYTE *)devSendResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
   LEAVE( __func__ );
   return WFA_SUCCESS;
}


/*
 * wfaStaStartWfdConnection(): 
 */ 
int wfaStaStartWfdConnection(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaStartWfdConn_t *staStartWfdConn= (caStaStartWfdConn_t *)caCmdBuf; //uncomment and use it
	ENTER( __func__ );
 
	/** TODO */
 
	strcpy(&infoResp.cmdru.wfdConnInfo.wfdSessionId[0], "1234567890");
	strcpy(&infoResp.cmdru.wfdConnInfo.p2pGrpId[0], "WIFI_DISPLAY"); 
	strcpy(&infoResp.cmdru.wfdConnInfo.result[0], "GO"); 

	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_START_WFD_CONNECTION_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf); 
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
	return WFA_SUCCESS;
}


int wfaStaCliCommand(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	char cmdName[32];
	char * pcmdStr,*str, *rstr;
	int  st;
	char CmdStr[WFA_CMD_STR_SZ];
	FILE *wfaCliFd;
	char wfaCliBuff[64];
	char retstr[256];
	int CmdReturnFlag;
	char tmp[256];
	FILE * sh_pipe;
	ENTER( __func__ );
    
	caStaCliCmdResp_t infoResp;
	memcpy(cmdName, strtok_r((char *)caCmdBuf, ",", (char **)&pcmdStr), 32);
	sprintf(CmdStr, "%s",cmdName);
	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
		   break;
		else
		{
		   sprintf(CmdStr, "%s /%s",CmdStr,str);
		   str = strtok_r(NULL, ",", &pcmdStr);
		   sprintf(CmdStr, "%s %s",CmdStr,str);
		}
	}

	CmdReturnFlag =0;
	wfaCliFd=fopen("/etc/WfaEndpoint/wfa_cli.txt","r");
	if(wfaCliFd!= NULL)
	{
	   while(fgets(wfaCliBuff, 64, wfaCliFd) != NULL)
	   {
		  if(ferror(wfaCliFd))
			  break;
		  str=strtok(wfaCliBuff,"-");
		  if(strcmp(str,cmdName) == 0)
		  {
			  str=strtok(NULL,",");
			  if(strcmp(str,"TRUE") == 0)
				  CmdReturnFlag =1;
			  break;
		  }
	   }
	   fclose(wfaCliFd);
	}
	
	st = 1;
	memset(&retstr[0],'\0',255);
	memset(&tmp[0],'\0',255);
	sprintf(gCmdStr, "%s",  CmdStr);
	printf("\nCLI Command -- %s\n", gCmdStr);
	sh_pipe = popen(gCmdStr,"r");
	if(!sh_pipe)
	{
		printf ("Error in opening pipe");
	}
    rstr = fgets(retstr,255,sh_pipe);
    if(rstr == NULL)
    {
        infoResp.status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_CLI_CMD_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
        *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
        return WFA_FAILURE;
    }
    if(pclose(sh_pipe) != 0)
    {
		printf("Error in closing shell cmd pipe");
    }
    sleep(2); 
    memcpy(tmp, strtok_r((char *)retstr, "-", (char **)&pcmdStr), 2);
    printf("\ncli status - %s",tmp);
    if(strlen(tmp) > 0)
       st = atoi(tmp);
    infoResp.resFlag=CmdReturnFlag;
    switch(st)
    {
        case 0:
        infoResp.status = STATUS_COMPLETE;
        if (CmdReturnFlag)
        {
           str=strtok_r(NULL, "\n", (char **)&pcmdStr);
           strncpy(tmp,str, 255);
           printf("\nresult - %s",tmp);
           if(tmp != NULL)
           {
               memset(&infoResp.result[0],'\0',WFA_CLI_CMD_RESP_LEN-1);       
               strncpy(&infoResp.result[0], tmp,(strlen(tmp) < WFA_CLI_CMD_RESP_LEN ) ? strlen(tmp) : (WFA_CLI_CMD_RESP_LEN-1) );
               printf("Return CLI result to CA: %s****\n", &infoResp.result[0]);   
           }
           else
               strcpy(&infoResp.result[0], "ENV_VAR_NOT_DEFINED");

        }
        break;
        case 1:
        infoResp.status = STATUS_ERROR;
        break;
        case 2:
        infoResp.status = STATUS_INVALID;
        break;
	}
	
	wfaEncodeTLV(WFA_STA_CLI_CMD_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );      
	return WFA_SUCCESS;
}
/*
 * wfaStaConnectGoStartWfd(): 
 */

int wfaStaConnectGoStartWfd(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
	caStaConnectGoStartWfd_t *staConnecGoStartWfd = (caStaConnectGoStartWfd_t *)caCmdBuf; 
 	ENTER( __func__ );
 
	/** TODO */
    
    strcpy(&infoResp.cmdru.wfdConnInfo.wfdSessionId[0], "1234567890");
    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_CONNECT_GO_START_WFD_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf); 
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );   
    return WFA_SUCCESS;
}

/*
 * wfaStaGenerateEvent(): 
 */

int wfaStaGenerateEvent(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaGenEvent_t *staGenerateEvent= (caStaGenEvent_t *)caCmdBuf; //uncomment and use it
    caWfdStaGenEvent_t *wfdGenEvent;
 	ENTER( __func__ );

    if(staGenerateEvent->program == PROG_TYPE_WFD)
    {
        wfdGenEvent = &staGenerateEvent->wfdEvent;
        if(wfdGenEvent ->type == eUibcGen)
        {
  
        } 
        else if(wfdGenEvent ->type == eUibcHid)
        {
  
        }  
        else if(wfdGenEvent ->type == eFrameSkip)
        {

        }
        else if(wfdGenEvent ->type == eI2cRead)
        {

        }
        else if(wfdGenEvent ->type == eI2cWrite)
        {

        }  
        else if(wfdGenEvent ->type == eInputContent)
        {

        }  
        else if(wfdGenEvent ->type == eIdrReq)
        {

        }  
    }

    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_GENERATE_EVENT_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf); 
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );  
    return WFA_SUCCESS;
}

 
/*
 * wfaStaReinvokeWfdSession(): 
 */

int wfaStaReinvokeWfdSession(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	caStaReinvokeWfdSession_t *staReinvokeSession= (caStaReinvokeWfdSession_t *)caCmdBuf; 
	ENTER( __func__ );
	/** TODO */

	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_REINVOKE_WFD_SESSION_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf); 
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ ); 
	return WFA_SUCCESS;
}


int wfaStaGetParameter(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	dutCmdResponse_t *getrssiResp = &gGenericResp;
	caStaGetParameter_t *staGetParam= (caStaGetParameter_t *)caCmdBuf; //uncomment and use it
	caStaGetParameterResp_t *paramList = &infoResp.cmdru.getParamValue;
	int ret;
	ENTER( __func__ );	

	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_WFD_PROG)) {
		// 6.1.1 get dev list part
		if(staGetParam->getParamValue == eDiscoveredDevList )
		{
			// Get the discovered devices, make space seperated list and return, check list is not bigger than 128 bytes.
			paramList->getParamType = eDiscoveredDevList;
			get_discovered_list( mrvl_dut_info->p2p_interface, (char *)&paramList->devList );
			infoResp.status = STATUS_COMPLETE;
			wfaEncodeTLV(WFA_STA_GET_PARAMETER_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
			LEAVE( __func__ );
			return WFA_SUCCESS;
		}
	}

	if (staGetParam->rssi_flag)
	{	
		ret = fetch_sta_rssi(mrvl_dut_info->sta_interface,getrssiResp->cmdru.rssi);
		if ( ret == FALSE ) {
			DPRINT_INFO(WFA_OUT,"FETCH_STA_RSSI_returned False\n");
			getrssiResp->status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_GET_PARAMETER_RESP_TLV, 4, (BYTE *)getrssiResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			LEAVE( __func__ );
			return WFA_FAILURE;
		}
		else {
			getrssiResp->status = STATUS_COMPLETE;
			//DPRINT_INFO(WFA_OUT,"FETCH_STA_RSSI_returned TRUE");
			printf("\nThe returned RSSI is in string rssi and is ----%s----\n",getrssiResp->cmdru.rssi);
			//DPRINT_INFO(WFA_OUT,"\nThe returned RSSI is in char string array rssi and is -\"%s\"",getrssiResp->cmdru.rssi);
			//DPRINT_INFO(WFA_OUT,"\n Set the rssi_flag in DUT-CMD-RSP and the rssi_resp_flag in CA-CMD-RSP");
			strcpy(paramList->rssi_resp,getrssiResp->cmdru.rssi);
			printf("\nThe Returned RSSI Must BE \"%s\"\n",paramList->rssi_resp);
			infoResp.status = STATUS_COMPLETE;
			wfaEncodeTLV(WFA_STA_GET_PARAMETER_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
			LEAVE( __func__ );
			return WFA_SUCCESS;
		}
	}	
	else {	
		infoResp.status = STATUS_COMPLETE;
		wfaEncodeTLV(WFA_STA_GET_PARAMETER_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
		LEAVE( __func__ );
		return WFA_SUCCESS;
	}
	LEAVE( __func__ );
}


int wfaStaSetSecurity(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{

   	dutCommand_t *cmd = (dutCommand_t *)caCmdBuf;
	dutCmdResponse_t *secResp = &gGenericResp;
    caStaSetSecurity_t *sec = &cmd->cmdsu.setsec;
	int ret; 
	ENTER( __func__ );
	char *ssid = sec->ssid;
	char *passphrase = sec->secu.passphrase;
	char *encrptype = sec->encpType;
	char *keyMgmtType = sec->keyMgmtType;
	char *str;
	int i,cnt,retu=0;
	FILE *tmpfd;
	char string[20];
	char modelv [20];
	int flag_for_9xxx_chip = 0;

	
	if (mrvl_dut_info->use_supplicant) {
		if (strlen(runtime_test_data->preset_non_pref_chan_list)) {
			sprintf(gCmdStr,"./%s -i%s set non_pref_chan '%s'",
							mrvl_WS_info->supplicant_cli_bin,
							mrvl_WS_info->sta_ctrl_interface,
							runtime_test_data->preset_non_pref_chan_list);
			system_with_log(gCmdStr);
		}
		mrvl_WS_info->network_index = get_supplicant_network_index(mrvl_WS_info->sta_ctrl_interface);
        if (sec->type == SEC_TYPE_SAE || sec->type == SEC_TYPE_SAE_PSK) {
            if (sec->groups_flag) {
                sprintf(gCmdStr, "%s/%s -i %s SET sae_groups %s",APP_BIN_LOC, mrvl_WS_info->supplicant_cli_bin,
                        mrvl_WS_info->sta_ctrl_interface, sec->groups);
                system_with_log(gCmdStr);			
            } else {
                sprintf(gCmdStr, "%s/%s -i %s SET sae_groups 19",APP_BIN_LOC, mrvl_WS_info->supplicant_cli_bin,
                        mrvl_WS_info->sta_ctrl_interface);
                system_with_log(gCmdStr);			
            }
            if (sec->sae_invalid_element_flag) {
                sprintf(gCmdStr, "%s/%s -i %s SET sae_commit_override %s",APP_BIN_LOC, mrvl_WS_info->supplicant_cli_bin,
                        mrvl_WS_info->sta_ctrl_interface, sec->sae_invalid_element);
                system_with_log(gCmdStr);
            }
        	}
        if (sec->type == SEC_TYPE_OWE) {
            if (sec->groups_flag && strcmp(sec->groups, "0") == 0) {
                printf("configure invalid OWE group\n");
                sprintf(gCmdStr, "%s/%s -i %s VENDOR_ELEM_ADD 13 ff23200000783590fb7440e03d5b3b33911f86affdcc6b4411b707846ac4ff08ddc8831ccd",APP_BIN_LOC, mrvl_WS_info->supplicant_cli_bin,
                        mrvl_WS_info->sta_ctrl_interface);
                system_with_log(gCmdStr);
            } else if (sec->groups_flag) {
                sprintf(gCmdStr, "%s/%s -i %s SET_NETWORK 0 owe_group %s",APP_BIN_LOC, mrvl_WS_info->supplicant_cli_bin,
                        mrvl_WS_info->sta_ctrl_interface, sec->groups);
                system_with_log(gCmdStr);
            }
        }
        if (sec->type == SEC_TYPE_EAPTLS || sec->type == SEC_TYPE_EAPTTLS) {
            printf("Setting security type EAP\n");
            mrvl_WS_info->network_index = get_supplicant_network_index(mrvl_WS_info->sta_ctrl_interface);
            ret = configure_supplicant_cli_eap(mrvl_WS_info->network_index, sec);
        }
	else {
            ret = configure_supplicant_cli(mrvl_WS_info->network_index, sec->type, encrptype, 
                    keyMgmtType, ssid, passphrase);
        }
		if (sec->pmf_flag) {
			if (sec->pmf == WFA_OPTIONAL) {
				sprintf(gCmdStr, "./%s -i %s SET_NETWORK %d ieee80211w 1",
								mrvl_WS_info->supplicant_cli_bin,
								mrvl_WS_info->sta_ctrl_interface,
								mrvl_WS_info->network_index);
				system_with_log(gCmdStr);
			} else if (sec->pmf == WFA_REQUIRED) {
				sprintf(gCmdStr, "./%s -i %s SET_NETWORK %d ieee80211w 2",
								mrvl_WS_info->supplicant_cli_bin,
								mrvl_WS_info->sta_ctrl_interface,
								mrvl_WS_info->network_index);
				system_with_log(gCmdStr);			
			} else if (sec->pmf == WFA_DISABLED) {
				sprintf(gCmdStr, "./%s -i %s SET_NETWORK %d ieee80211w 0",
								mrvl_WS_info->supplicant_cli_bin,
								mrvl_WS_info->sta_ctrl_interface,
								mrvl_WS_info->network_index);
				system_with_log(gCmdStr);			
			} 
		
		}
		} 
	else {
			        sprintf(gCmdStr,"killall wpa_supplicant");
				system_with_log(gCmdStr);
				sprintf(gCmdStr,"killall wpa_supplicant");
				system_with_log(gCmdStr);
				sprintf(gCmdStr,"./mlanutl mlan0 version | cut -d : -f2 | cut -d. -f1 > /tmp/getmodel.txt");
				system_with_log(gCmdStr);

					{
						tmpfd = fopen("/tmp/getmodel.txt", "r+");
							if(tmpfd == NULL) {
								return FALSE;
							}
							if(fgets(string, 20, tmpfd) == NULL) {
								return FALSE;
							}
							
							if ( string[strlen(string) == '\n' ] )
								string[strlen(string) -1] = '\0';	
							
							strcpy(modelv, string);
							fclose(tmpfd);
							
							if (strstr (modelv,"90") != NULL)
								{ flag_for_9xxx_chip = 1 ;
								printf("\nThis is a 90xx model\n\r");
								}
					}
				

		 		if ((sec->type == SEC_TYPE_SAE) || (sec->type == SEC_TYPE_SAE_PSK) && (flag_for_9xxx_chip==1) )
				{
		 		sprintf(gCmdStr,"./mlanutl mlan0 authtype 3");
				system_with_log(gCmdStr);
				sprintf(gCmdStr,"./mlanutl mlan0 reassoctrl 1");
				system_with_log(gCmdStr);
				sprintf(gCmdStr,"./mlanutl mlan0 pmfcfg 1 1");
				system_with_log(gCmdStr);
				sprintf(gCmdStr, "%s/%s mlan0 passphrase \"1;ssid=%s;sae_password=%s\"",APP_BIN_LOC,MLANUTL,ssid, passphrase);
				system_with_log(gCmdStr);
				ret =TRUE;
		 		}
		 		else if ((sec->type == SEC_TYPE_SAE) || (sec->type == SEC_TYPE_SAE_PSK) && (flag_for_9xxx_chip==0) )
				{
		 		sprintf(gCmdStr,"./mlanutl mlan0 authtype 3");
				system_with_log(gCmdStr);
				sprintf(gCmdStr,"./mlanutl mlan0 reassoctrl 1");
				system_with_log(gCmdStr);
				sprintf(gCmdStr,"./mlanutl mlan0 pmfcfg 1 1");
				system_with_log(gCmdStr);
				ret = set_mlan_passphrase(mrvl_dut_info->sta_interface,ssid,passphrase);
		 		}
		               else 
					ret = set_mlan_passphrase(mrvl_dut_info->sta_interface,ssid,passphrase);
		 			
		}
	secResp->status = STATUS_COMPLETE;   
	wfaEncodeTLV(WFA_STA_SET_SECURITY_RESP_TLV, 4, (BYTE *)secResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return WFA_SUCCESS;
}
		
/*
 * This is used to set a temporary MAC address of an interface
 */
int wfaStaSetMacAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCommand_t *cmd = (dutCommand_t *)caCmdBuf;
	dutCmdResponse_t *staCmdResp = &gGenericResp;
	char *macaddr = &cmd->cmdsu.macaddr[0];
	ENTER( __func__ );
	
	/** TODO */
	
	wfaEncodeTLV(WFA_STA_SET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
	return WFA_SUCCESS;
}

/*
 * wfaStaWpsReadLabel():
 */
int wfaStaWpsReadLabel(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaWpsReadLabel_t *getStaWpsReadLabel= (caStaWpsReadLabel_t *)caCmdBuf;
    ENTER( __func__ );
	
	/** TODO */
	
	strcpy(&infoResp.cmdru.wpsPin[0],"");
    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
    return TRUE;
}

/*
 * wfaStaSetWpsPbc():
 */
int wfaStaSetWpsPbc(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    dutCommand_t *getStaSetWpsPbc= (dutCommand_t *)caCmdBuf;
    int ret;
	ENTER( __func__ );

	if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
		if (runtime_test_data->autogo) {
		    ret = set_supplicant_wps_pbc(mrvl_WS_info->p2p_ctrl_interface);			
		}
	} else if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
		if (runtime_test_data->autogo) {
			ret = set_mwud_wps_registrar(mrvl_dut_info->p2p_interface,runtime_test_data->ssid);
		}		
	}
	
	strcpy(runtime_test_data->wps_pin,"");
	strcpy(runtime_test_data->wps_method,WPS_PBC);	
	
    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_WPS_SETWPS_PBC_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
    return TRUE;
}

/*
 * wfaStaWpsReadPin():
 */
int wfaStaWpsReadPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    dutCommand_t *getStaWpsReadPin= (dutCommand_t *)caCmdBuf;
    int ret;
	ENTER( __func__ );
   
	if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
		ret = get_supplicant_read_pin(infoResp.cmdru.wpsPin);
		if (runtime_test_data->autogo) {
			ret = set_supplicant_readpin(mrvl_WS_info->p2p_ctrl_interface,infoResp.cmdru.wpsPin);
		}
	} else if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
		ret = get_mwud_read_pin(mrvl_dut_info->p2p_interface,infoResp.cmdru.wpsPin);		
		if (runtime_test_data->autogo) {
			ret = set_mwud_wps_registrar(mrvl_dut_info->p2p_interface,runtime_test_data->ssid);			
		}
	}
	strcpy(runtime_test_data->wps_pin,infoResp.cmdru.wpsPin);
	strcpy(runtime_test_data->wps_method,READ_WPS_PIN);	
	
    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
    return TRUE;
}

/*
 * wfaStaWpsEnterPin():
 */
int wfaStaWpsEnterPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaWpsEnterPin_t *getStaWpsEnterPin= (caStaWpsEnterPin_t *)caCmdBuf;
	int ret; 
	ENTER( __func__ );
	
    char *pin =getStaWpsEnterPin-> wpsPin;
	if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
		if (runtime_test_data->autogo) {
			ret = set_supplicant_wps_pin(mrvl_WS_info->p2p_ctrl_interface,pin);
		}
	} else if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
		if (runtime_test_data->autogo) {
			ret = set_mwud_wps_registrar(mrvl_dut_info->p2p_interface,runtime_test_data->ssid);					
		}
	}
	
	strcpy(runtime_test_data->wps_pin,pin);
	strcpy(runtime_test_data->wps_method,ENTER_WPS_PIN);	
	
    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_WPS_ENTER_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
    return TRUE;
}

/*
 * wfaStaGetPsk():
 */
int wfaStaGetPsk(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    caStaGetPsk_t *getStaGetPsk= (caStaGetPsk_t *)caCmdBuf;	
    int ret;
	ENTER( __func__ );
	char ssid[32] = {0};
	char passPhrase[32] = {0};
		
	if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_P2P_PROG) || !strcasecmp(SIGMA_PROG_NAME,MRVL_WFD_PROG) ) {
		if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
			ret = fetch_supplicant_passphrase(mrvl_WS_info->p2p_ctrl_interface,passPhrase);	
			ret = fetch_supplicant_ssid(mrvl_WS_info->p2p_ctrl_interface,ssid,mrvl_WS_info->network_index);
		} else {
			ret = fetch_mlan_passphrase(mrvl_dut_info->p2p_interface,passPhrase);
			ret = fetch_mlan_ssid(mrvl_dut_info->p2p_interface,ssid);
		}
	} else {
		ret = fetch_mlan_passphrase(mrvl_dut_info->sta_interface,passPhrase);
		ret = fetch_mlan_ssid(mrvl_dut_info->sta_interface,ssid);
	}
	strcpy(infoResp.cmdru.pskInfo.ssid,ssid);
	strcpy(infoResp.cmdru.pskInfo.passPhrase,passPhrase);
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_GET_PSK_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
    return TRUE;
}

/*
 * wfaStaP2pReset():
 */
int wfaStaP2pReset(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    dutCommand_t *getStaP2pReset = (dutCommand_t *)caCmdBuf;
    int ret;
	FILE *fp=NULL;
	ENTER( __func__ );
	
	kill_wlan_utilities();

	if (!strcasecmp(SIGMA_PROG_UTILITY,WPA_SUPPLICANT)) {
		ret = clear_supplicant_instance();
		ret = reload_wlan_build();
		ret = enable_driver_debug(mrvl_dut_info->p2p_interface,"0x300b7");
		fp = fopen(SUPPLICANT_CONF,"w");
		if ( fp == NULL ) {
			DPRINT_ERR(WFA_ERR,"File Opening error");
			infoResp.status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_P2P_RESET_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			LEAVE( __func__ );
			return WFA_FAILURE;
		}
		fprintf(fp,"ctrl_interface=%s\n",SUPPLICANT_CTRL_PATH);		
		fprintf(fp,"ap_scan=1\n");		
		fclose(fp);					
		launch_supplicant_file_instance(mrvl_dut_info->p2p_interface);
	} else if (!strcasecmp(SIGMA_PROG_UTILITY,MWUD)) {
		ret = clear_mwud_instance(mrvl_dut_info->p2p_interface);		
		ret = reload_wlan_build();
		ret = launch_mwud_service(mrvl_dut_info->p2p_interface);	
		ret = init_mwud_wifidirect(mrvl_dut_info->p2p_interface,DEFAULT_CHAN,DEFAULT_CHAN,DEFAULT_INTENT,mrvl_dut_info->config_methods);
	}
		
	/* Reset Runtime variables */
	runtime_test_data->autogo =0;
	runtime_test_data->reinvoke =0;
	runtime_test_data->oper_chn =DEFAULT_CHAN;
	runtime_test_data->listen_chn =DEFAULT_CHAN;
	runtime_test_data->grpCapability =32;
	runtime_test_data->devCapability =8;
	strcpy(runtime_test_data->ssid,"DIRECT-");
		
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_P2P_RESET_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
    return TRUE;
}

#ifdef EXPERIMENTAL_AP_SUPPORT

int wfaApSet11nWireless(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caApSet11nWireless_t *set11n = (caApSet11nWireless_t *)caCmdBuf;
	dutCmdResponse_t infoResp;
	ENTER( __func__ ); 
  
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_AP_SET_11N_WIRELESS_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
	return WFA_SUCCESS;
}

int wfaApSetPmf(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caApSetPmf_t *setpmf = (caApSetPmf_t *)caCmdBuf;
	dutCmdResponse_t infoResp;
	ENTER( __func__ ); 
	int ret;
	if (HOSTAPD) {
		ret = hostapd_pmf_capabilities(setpmf->pmf);
	} else 
		ret = configure_pmf_capabilities(mrvl_dut_info->sta_interface,setpmf->pmf);
	if ( ret != TRUE ) {
		infoResp.status = STATUS_ERROR;
		wfaEncodeTLV(WFA_AP_SET_PMF_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
		LEAVE( __func__ );
		return FALSE;
	}
		
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_AP_SET_PMF_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
	return WFA_SUCCESS;
}

int wfaApGetMacAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caApGetMacAddress_t *getMac = (caApGetMacAddress_t *)caCmdBuf;
	dutCmdResponse_t infoResp;
	caApGetMacAddressResp_t *macResp = &(infoResp.cmdru.apMacAddrInfo);
	ENTER( __func__ ); 
	int ret; 
	
	ret = fetch_mac_address(mrvl_dut_info->mmh_interface,macResp->mac);
	if ( ret != TRUE ) {
		infoResp.status = STATUS_ERROR;
		wfaEncodeTLV(WFA_AP_GET_MAC_ADDRESS_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
		LEAVE( __func__ );
		return FALSE;
	}

	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_AP_GET_MAC_ADDRESS_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
	return WFA_SUCCESS;
}

int wfaApDeauthSta(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caApDeauthSta_t *deauthsta = (caApDeauthSta_t *)caCmdBuf;
	dutCmdResponse_t infoResp;
    ENTER( __func__ ); 
	if (HOSTAPD) {
		sprintf(gCmdStr, "%s/%s deauthenticate %s",APP_BIN_LOC,mrvl_hostapd_info->hostapd_cli_bin,deauthsta->sta_mac_address);			
		system_with_log(gCmdStr);	
	} else {	
		if ( !strcmp(deauthsta->sta_mac_address,"ff:ff:ff:ff:ff:ff") ) {
			sprintf(gCmdStr, "%s/%s bss_stop",APP_BIN_LOC,UAPUTL);			
			system_with_log(gCmdStr);
		} else {
			sprintf(gCmdStr, "%s/%s sta_deauth %s",APP_BIN_LOC,UAPUTL,deauthsta->sta_mac_address);
			system_with_log(gCmdStr);
		}	  
	}
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_AP_DEAUTH_STA_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);
	LEAVE( __func__ );
	return WFA_SUCCESS;
}

int wfaAPSet11d(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caAPSet11d_t *apSet11d = (caAPSet11d_t *) caCmdBuf;
    dutCmdResponse_t *apSet11dResp = &gGenericResp;   
	int ret;
	FILE *fp;
    ENTER( __func__ ); 
	if (HOSTAPD) {
			ret = generate_hostapd_conf(); 
			fp = fopen(HOSTAPD_CONF, "a+");
			if (fp == NULL) {
				apSet11dResp->status = STATUS_ERROR;
				wfaEncodeTLV(WFA_AP_SET_11D_TLV,  4, (BYTE *)apSet11dResp, respBuf);
				*respLen = WFA_TLV_HDR_LEN + 4;
				LEAVE( __func__ );
				return WFA_FAILURE;
			}
		if(apSet11d->CountryCode_flag){
		fprintf(fp,"ieee80211d=1\n");
		fprintf(fp,"ieee80211h=1\n");
		fprintf(fp,"country_code=%s\n",apSet11d->CountryCode);
			}
		
		fclose(fp);
		
		}

	else
	sprintf(gCmdStr,"%s/%s sys_cfg_80211d state 1 country %s",APP_BIN_LOC,UAPUTL,apSet11d->CountryCode);
	system_with_log(gCmdStr);

	
 
    apSet11dResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_AP_SET_11D_TLV,  4, (BYTE *)apSet11dResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return WFA_SUCCESS; 
}

//DD 11H implementation --- START
int wfaAPSet11h(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caAPSet11h_t *apSet11h = (caAPSet11h_t *) caCmdBuf;
    dutCmdResponse_t *apSet11hResp = &gGenericResp;   
	int ret;
	FILE *fp;

    ENTER( __func__ ); 
	if (HOSTAPD) {

		ret = generate_hostapd_conf(); 
		fp = fopen(HOSTAPD_CONF, "a+");
		
		if (fp == NULL) 
		{
			apSet11hResp->status = STATUS_ERROR;
			wfaEncodeTLV(WFA_AP_SET_11H_TLV,  4, (BYTE *)apSet11hResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			LEAVE( __func__ );
			return WFA_FAILURE;
		}

	
		if (apSet11h->sim_dfs_flag==1) 
			{
			sprintf(gCmdStr, "%s/%s uap0 channel_switch 1 0 36 10 ", APP_BIN_LOC,MLANUTL);
			system_with_log(gCmdStr);
			}
		
		if (apSet11h->dfs_flag==1)
			{
		fprintf(fp,"ieee80211d=1\n");
		fprintf(fp,"ieee80211h=1\n");
		fprintf(fp,"country_code=US\n");
			}

		fclose(fp);
		}

	else {
		if (apSet11h->sim_dfs_flag==1) {
			sprintf(gCmdStr, "%s/%s uap0 channel_switch 1 0 36 10 ", APP_BIN_LOC,MLANUTL);
			system_with_log(gCmdStr);
			}
		}
	
    apSet11hResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_AP_SET_11H_TLV,  4, (BYTE *)apSet11hResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
    return WFA_SUCCESS; 
}

//DD 11H implementation ---Finish


int get_ssid(char *ssid)
{
    FILE *pipe = NULL;
    char tmpStr[100], cmdStr[255] = {0};
    int i = 0;

    sprintf(cmdStr, "./uaputl.exe sys_cfg_ssid | grep -i \"SSID =\"");
    printf("\n=> %s\n", cmdStr);
    pipe = popen(cmdStr, "r");
    fgets(tmpStr, 100, pipe);
    printf("==> %s\n", tmpStr);
    pclose(pipe);
    if (tmpStr[strlen(tmpStr)] == '\n')
        tmpStr[strlen(tmpStr)] = '\0';
    /* The ret format:
     * SSID = xxx
     */
    strncpy(ssid, tmpStr + strlen("SSID = "), 31);
    ssid[31] = '\0';
    while(i < 32) {
        if (ssid[i] == '\n') {
            ssid[i] = '\0';
            break;
        }
        i++;
    }
    return 0;
}

int get_channel(int *ch)
{
    FILE *pipe = NULL;
    char tmpStr[100], cmdStr[255] = {0};

    sprintf(cmdStr, "./uaputl.exe sys_cfg_channel | grep -i \"channel =\"");
    printf("\n=> %s\n", cmdStr);
    pipe = popen(cmdStr, "r");
    fgets(tmpStr, 100, pipe);
    printf("==> %s\n", tmpStr);
    pclose(pipe);
    if (tmpStr[strlen(tmpStr)] == '\n')
        tmpStr[strlen(tmpStr)] = '\0';
    /* The ret format:
     * Channel = xxx
     */
    *ch = (int)strtol(tmpStr + strlen("Channel = "), NULL, 10);
    return 0;
}

int wfaAPConfigCommit(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   //dutCommand_t *dutCmd = (dutCommand_t *)caCmdBuf;
   caAPConfigCommit_t *apConfigCommit = (caAPConfigCommit_t *) caCmdBuf;
   char *ifname = apConfigCommit->intf;
   int status = 0;
   dutCmdResponse_t *apConfigCommitResp = &gGenericResp;
   int nss = 1;
   char ssid[32] = {0};
   int ch = 0;
   strcpy(apConfigCommitResp->cmdru.reason, "unknown");
   
    printf("\nEntering wfaAPConfigCommit\n");

	if (HOSTAPD) {
		console_dump_file(HOSTAPD_CONF);
        sprintf(gCmdStr, "killall %s",mrvl_hostapd_info->hostapd_bin);
		system_with_log(gCmdStr);
		sleep(2);

		sprintf(gCmdStr,"\cp -rf %s hostapd_test.conf",HOSTAPD_CONF);
		system_with_log(gCmdStr);
				
		sprintf(gCmdStr,"rm -rf %s",HOSTAPD_CONF);
		system_with_log(gCmdStr);

		sprintf(gCmdStr, "./%s hostapd_test.conf > hostapd.log &",mrvl_hostapd_info->hostapd_bin);
		system_with_log(gCmdStr);
		sleep(5);
		apConfigCommitResp->status = STATUS_COMPLETE;
		wfaEncodeTLV(WFA_AP_CONFIG_COMMIT_TLV, sizeof(dutCmdResponse_t), (BYTE *)apConfigCommitResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
		return WFA_SUCCESS; 
	}
	
    if (ifname[0] == '\0') {
        printf("Use uap0 as ap interface name!\n");
        sprintf(ifname, "uap0");
    }
    if (ap_use_hostapd != 0) {
        get_ssid(ssid);
        printf("Get ssid:%s\n", ssid);
        get_channel(&ch);
        printf("Get channel:%d\n", ch);

        sprintf(gCmdStr, "echo ssid=%s >> %s",
            ssid,   HOSTAPD_CONF_ENT);
        system_with_log(gCmdStr);

        sprintf(gCmdStr, "killall hostapd");
        system_with_log(gCmdStr);
        sprintf(gCmdStr, "./uaputl.exe sys_cfg_rates"
                " 0x82 0x84 0x8b 0x96 0xc 0x12 0x18 0x24 0x30 0x48 0x60 0x6c");
        system_with_log(gCmdStr);
        sprintf(gCmdStr, "%s %s &",   HOSTAPD_BIN,
              HOSTAPD_CONF_ENT);
        system_with_log(gCmdStr);
        ap_use_hostapd = 0;

        sleep(5);
        sprintf(gCmdStr, "%s/start-cert-ap.sh %d",   ch);
        system_with_log(gCmdStr);

        status = 0;
        goto done;
    }

   if (ap_mcs_fixedrate != 0xff) {
	if ((ap_saved_txmcsmap & 0xc) != 0xc)
		nss = 2;
	printf("ap_saved_txmcsmap=0x%08x, nss=%d\n", ap_saved_txmcsmap, nss);
	sprintf(gCmdStr, "./mlanutl uap0 txratecfg 2 %d %d",
			ap_mcs_fixedrate, nss); 
        system_with_log(gCmdStr);
	ap_mcs_fixedrate = 0xff;
   }
   
   if (ap_be_flag) {
        sprintf(gCmdStr, "./uaputl.exe sys_cfg_wmm 0 %d %d %d %d",
                be.aifs, be.cwmax, be.cwmin, be.txop);
        system_with_log(gCmdStr);
   }
   
   if (ap_bk_flag) {
        sprintf(gCmdStr, "./uaputl.exe sys_cfg_wmm 1 %d %d %d %d",
                bk.aifs, bk.cwmax, bk.cwmin, bk.txop);
        system_with_log(gCmdStr);
   }
   
   if (ap_vi_flag) {
        sprintf(gCmdStr, "./uaputl.exe sys_cfg_wmm 2 %d %d %d %d",
                vi.aifs, vi.cwmax, vi.cwmin, vi.txop);
        system_with_log(gCmdStr);
   }
   
   if (ap_vo_flag) {
        sprintf(gCmdStr, "./uaputl.exe sys_cfg_wmm 3 %d %d %d %d",
                vo.aifs, vo.cwmax, vo.cwmin, vo.txop);
        system_with_log(gCmdStr);
   }
 
   sprintf(gCmdStr, "ifconfig uap0 down"); 
   system_with_log(gCmdStr);
   
   /* sprintf(gCmdStr, "uaputl.exe bss_start"); */
   /* use uap private for bss start - This is for bypassing the cipher protocol
    * validity in case of vht_tkip and vht_wep tests */
   //system_with_log("uaputl.exe sys_cfg_80211d state 1 country US");
   printf("\nUsing the iwpriv instead of uaputl.exe for bss_start...\n");
   sprintf(gCmdStr, "./uaputl.exe bss_start");
   status = system_with_log(gCmdStr);

   sprintf(gCmdStr, "ifconfig uap0 up"); 
   system_with_log(gCmdStr);
   ap_vht_bw = 1; /* Set it back to the default: follow BW(80/160/80+80) from vht cap */
   ap_ch_width = 80;
   
   //Reset global variable
   width = 0;
   bw_signal = 0;
   bw_signal_flag = 0;
   dyn_bw_signal = 0;
   dyn_bw_signal_flag = 0;

done:
   if (status == 0) {
       apConfigCommitResp->status = STATUS_COMPLETE;
   } else {
       if (invalid_for_11ac == 1) {
           strcpy(apConfigCommitResp->cmdru.reason, "Requested configuration is not supported.");
           printf("==> %s\n", apConfigCommitResp->cmdru.reason); /*Requested configuration is not supported.")*/
           apConfigCommitResp->status = STATUS_INVALID;
       } else {
           apConfigCommitResp->status = STATUS_ERROR; 
       }
   }
   wfaEncodeTLV(WFA_AP_CONFIG_COMMIT_TLV, sizeof(dutCmdResponse_t), (BYTE *)apConfigCommitResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return WFA_SUCCESS; 
}

int wfaAPReboot(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   //dutCommand_t *dutCmd = (dutCommand_t *)caCmdBuf;
   caAPSetSecurity_t *apSecurity = (caAPSetSecurity_t *) caCmdBuf;
   char *ifname = apSecurity->intf;
   dutCmdResponse_t *apRebootResp = &gGenericResp; 
   printf("\nEntering wfaAPReboot"); 
   
   printf("1\n");
   printf("2\n");
   printf("3\n");
   printf("4\n");
   printf("5\n");
   printf("6\n");
   apRebootResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_AP_REBOOT_TLV,  4, (BYTE *)apRebootResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   printf("\nLeaving wfaAPReboot"); 
   return WFA_SUCCESS; 
}
/*
 * wfaAPSetWireless():
 *    This is an experimental fucntion for setting some specific wireless
 *    parameters on Marvell Micro AP
 *
 *    Currently this function is just implemented as a prototype to verify the
 *    CA <--> DUT communication. Need to update the function to perform as
 *    expected. All the optional params are made available using flags for
 *    perticular variable. e.g ssid_flag is set indicates ssid is received from
 *    UCC and this funciton needs to set it adn so on.
 */

int wfaAPSetWireless(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caAPSetWireless_t *set_wireless_params = (caAPSetWireless_t *) caCmdBuf;
    dutCmdResponse_t *apSetWirelessResp = &gGenericResp;
    int ret;
	FILE *fp;
	ENTER( __func__ );
	
	if (HOSTAPD) {
		ret = generate_hostapd_conf(); 
        fp = fopen(HOSTAPD_CONF, "a+");
        if (fp == NULL) {
            apSetWirelessResp->status = STATUS_ERROR;
            wfaEncodeTLV(WFA_AP_SET_WIRELESS_TLV, 4, (BYTE *)apSetWirelessResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + 4;
            LEAVE( __func__ );
            return WFA_FAILURE;
        }
        if (set_wireless_params->channel_flag) {
            if (set_wireless_params->channel < MIN_A_CHANNEL) 
				fprintf(fp,"hw_mode=g\n");
             else 
				fprintf(fp,"hw_mode=a\n");
			fprintf(fp,"channel=%d\n",set_wireless_params->channel);
			if (set_wireless_params->channel >= MIN_A_CHANNEL) {
				fprintf(fp,"vht_oper_chwidth=1\n");
				char channel_freq_idx[4] = {0};
				sprintf(gCmdStr,"%d",set_wireless_params->channel);
				read_ini_config("Channel_Freq.conf","Chan_Freq_80MHz",gCmdStr,channel_freq_idx);
				fprintf(fp,"vht_oper_centr_freq_seg0_idx=%s\n",channel_freq_idx);

			if (set_wireless_params->DFS_CHAN_FLAG)
					{
					fprintf(fp,"ieee80211d=1\n");
					fprintf(fp,"ieee80211h=1\n");
					fprintf(fp,"country_code=US\n");
					}
			if (set_wireless_params->HT_20_ONLY_FLAG)
			{
				if (set_wireless_params->channel == 140)
				{     fprintf(fp,"vht_oper_chwidth=0\n");
					fprintf(fp,"vht_oper_centr_freq_seg0_idx=0\n");
					fprintf(fp,"ieee80211d=1\n");
					fprintf(fp,"ieee80211h=1\n");
					fprintf(fp,"country_code=US\n");
					}
				else if (set_wireless_params->channel == 165)
				{  
					fprintf(fp,"vht_oper_chwidth=0\n");
					fprintf(fp,"vht_oper_centr_freq_seg0_idx=0\n");
					fprintf(fp,"ieee80211d=1\n");
					fprintf(fp,"ieee80211h=1\n");
					fprintf(fp,"country_code=US\n");
					}
				}

			if (set_wireless_params->HT_40_PLUS_FLAG)
					fprintf(fp,"ht_capab=[HT40+]\n");
			if (set_wireless_params->HT_40_MINUS_FLAG)
					fprintf(fp,"ht_capab=[HT40-]\n");
			
			}
		}
		
		if (set_wireless_params->ssid_flag) 
			fprintf(fp,"ssid=%s\n",set_wireless_params->ssid);

		if (set_wireless_params->bcnint_flag) 
			fprintf(fp,"beacon_int=%s\n",set_wireless_params->bcnint);

		if (set_wireless_params->mode_flag) {
			if(strncmp(set_wireless_params->mode, "11ac",4)==0) {
				fprintf(fp,"ieee80211ac=1\n");
				fprintf(fp,"ieee80211w=1\n");
			}
}
		if(set_wireless_params->country_code_flag){
		fprintf(fp,"ieee80211d=1\n");
		fprintf(fp,"ieee80211h=1\n");
		fprintf(fp,"country_code=%s\n",set_wireless_params->country_code);
			}
		
		fclose(fp);
		} 

	else {
		ret = mrvlAPSetWirelessVHT(len, caCmdBuf, respLen, respBuf);	
		}
	
	apSetWirelessResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_AP_SET_WIRELESS_TLV, 4, (BYTE *)apSetWirelessResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
	return WFA_SUCCESS; 
}

int wfaAPSetSecurity(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caAPSetSecurity_t *apSecurity = (caAPSetSecurity_t *) caCmdBuf;
    dutCmdResponse_t *apSetSecurityResp = &gGenericResp;
    int ret; 
	FILE *fp;
	ENTER( __func__ );
	
	if (HOSTAPD) {
		fp = fopen(HOSTAPD_CONF,"a+");
		if ( fp == NULL ) {
			apSetSecurityResp->status = STATUS_ERROR;
			wfaEncodeTLV(WFA_AP_SET_SECURITY_TLV, 4, (BYTE *)apSetSecurityResp, respBuf); 
			*respLen = WFA_TLV_HDR_LEN + 4;
			LEAVE( __func__ );
			return WFA_FAILURE;
			}
		char sha246[32] = {0};
		if (!strcasecmp(SIGMA_PROG_NAME,MRVL_PMF_PROG)) {
			if (!strcasecmp(apSecurity->pmf,"optional") && !strcasecmp(apSecurity->sha256ad,"enabled"))
				strcpy(sha246," WPA-PSK-SHA256");
			if (!strcasecmp(apSecurity->pmf,"required"))
				strcpy(sha246,"-SHA256");
		}
				
		if (strncasecmp(apSecurity->keymgnt, "NONE", 5) == 0) {
			// DO NOTHING
		} else if (strncasecmp(apSecurity->keymgnt, "WPA-PSK", 8) == 0) {
			fprintf(fp,"wpa_key_mgmt=WPA-PSK%s\n",sha246);
			fprintf(fp,"wpa=1\n");
			fprintf(fp,"wpa_pairwise=TKIP\n");
			fprintf(fp,"auth_algs=1\n");
		} else if (strncasecmp(apSecurity->keymgnt, "WPA2-PSK", 9)== 0) {
			fprintf(fp,"wpa_key_mgmt=WPA-PSK%s\n",sha246);
			fprintf(fp,"wpa=2\n");
			fprintf(fp,"wpa_pairwise=CCMP\n");
			fprintf(fp,"auth_algs=1\n");
		} else if (strncasecmp(apSecurity->keymgnt, "WPA2-PSK-MIXED", 14) == 0) {
			fprintf(fp,"wpa_key_mgmt=WPA-PSK%s\n",sha246);
			fprintf(fp,"wpa=3\n");
			fprintf(fp,"wpa_pairwise=TKIP CCMP\n");
			fprintf(fp,"auth_algs=1\n");
		} 
		else if (strncasecmp(apSecurity->keymgnt, "WPA2-Ent", 9) == 0) {
			/* TODO */
		} else {
			/* DO NOTHING */
		}
		
		if (apSecurity->psk_flag == 1)
			fprintf(fp,"wpa_passphrase=%s\n",apSecurity->psk);
			
		if (apSecurity->wep_flag == 1) {
			fprintf(fp,"auth_algs=1\n");
			fprintf(fp,"wep_default_key=0\n");
			fprintf(fp,"wep_key0=%s\n",apSecurity->wepkey);
		}
		if (!strcasecmp(SIGMA_PROG_NAME,MRVL_PMF_PROG)) {
			if (!strcasecmp(apSecurity->pmf,"optional"))
				fprintf(fp,"ieee80211w=1\n");
			if (!strcasecmp(apSecurity->pmf,"required"))
				fprintf(fp,"ieee80211w=2\n");
		}
		if (SIGMA_PROG_NAME,MRVL_WPA3_PROG){
			/* DD Changes for SAE-APUT--START */
			 if (strncasecmp(apSecurity->keymgnt, "SAE", 3)== 0) {
							   fprintf(fp,"wpa_key_mgmt=SAE\n");
							   fprintf(fp,"wpa=2\n");
							   fprintf(fp,"wpa_pairwise=CCMP\n");
							   fprintf(fp,"auth_algs=1\n");
							   fprintf(fp,"ieee80211w=2\n");
							   fprintf(fp,"sae_groups=19 20 21 \n");
							   fprintf(fp,"sae_require_mfp=1\n");
							   fprintf(fp,"sae_anti_clogging_threshold=10\n");
						   }
			  else if (strncasecmp(apSecurity->keymgnt, "WPA2-PSK-SAE", 12)== 0) {
						fprintf(fp,"wpa_key_mgmt=WPA-PSK SAE\n");
						fprintf(fp,"wpa=2\n");
						fprintf(fp,"wpa_pairwise=CCMP\n");
						fprintf(fp,"auth_algs=1\n");
						fprintf(fp,"ieee80211w=1\n");
						fprintf(fp,"sae_groups=19 20 21 \n");
						fprintf(fp,"sae_require_mfp=1\n");
						fprintf(fp,"sae_anti_clogging_threshold=10\n");
					}
			/* DD Changes for SAE-APUT --END-- */

		}
		fclose(fp);
	} else {
		if ( !strcasecmp(SIGMA_PROG_NAME,MRVL_PMF_PROG) ) {
			ret = mrvlAPSetSecurityPMF(len,caCmdBuf,respLen,respBuf);
		} else {
			ret = mrvlAPSetSecurityVHT(len,caCmdBuf,respLen,respBuf);
		}
	}	
	apSetSecurityResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_AP_SET_SECURITY_TLV, 4, (BYTE *)apSetSecurityResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
	return WFA_SUCCESS; 
}

int wfaAPSet11n(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caAPSet11n_t *apSet11n = (caAPSet11n_t *) caCmdBuf;
   char *ifname = apSet11n->intf;
   dutCmdResponse_t *apSet11nResp = &gGenericResp;
   ENTER( __func__ ); 
   
   /** TODO */
	
   apSet11nResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_AP_SET_11N_TLV,  4, (BYTE *)apSet11nResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;
   LEAVE( __func__ );
   return WFA_SUCCESS; 
}

int wfaAPResetDefault(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caAPResetDefault_t *apResetDefault = (caAPResetDefault_t *) caCmdBuf;
	dutCmdResponse_t *apResetDefaultResp = &gGenericResp;
	int ret; 
	FILE *fp; 
	ENTER( __func__ ); 
	
	if (HOSTAPD) {
		ret = generate_hostapd_conf();
		kill_wlan_utilities();
		reload_wlan_build();
	} else {
		ret = mrvlAPResetDefaultVHT(len,caCmdBuf,respLen,respBuf);
	}
     
   apResetDefaultResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_AP_RESET_DEFAULT_TLV,  4, (BYTE *)apResetDefaultResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;
   LEAVE( __func__ );
   return WFA_SUCCESS; 
}

int wfaAPSetStaQos(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caAPSetStaQos_t *apSetStaQos = (caAPSetStaQos_t *) caCmdBuf;
   char *ifname = apSetStaQos->intf;
   dutCmdResponse_t *apSetStaQosResp = &gGenericResp;
   ENTER( __func__ );
   
	if (apSetStaQos->be.cwmin_flag == 1)
		be.cwmin = apSetStaQos->be.cwmin;
	if (apSetStaQos->be.cwmax_flag == 1)
		be.cwmax = apSetStaQos->be.cwmax;
	if (apSetStaQos->be.aifs_flag == 1)
		be.aifs = apSetStaQos->be.aifs;
	if (apSetStaQos->be.txop_flag == 1)
		be.txop = apSetStaQos->be.txop;   
	if (apSetStaQos->bk.cwmin_flag == 1)
		bk.cwmin = apSetStaQos->bk.cwmin;
	if (apSetStaQos->bk.cwmax_flag == 1)
		bk.cwmax = apSetStaQos->bk.cwmax;
	if (apSetStaQos->bk.aifs_flag == 1)
		bk.aifs = apSetStaQos->bk.aifs;
	if (apSetStaQos->bk.txop_flag == 1)
		bk.txop = apSetStaQos->bk.txop;
	if (apSetStaQos->vi.cwmin_flag == 1)
		vi.cwmin = apSetStaQos->vi.cwmin;
	if (apSetStaQos->vi.cwmax_flag == 1)
		vi.cwmax = apSetStaQos->vi.cwmax;
	if (apSetStaQos->vi.aifs_flag == 1)
		vi.aifs = apSetStaQos->vi.aifs;
	if (apSetStaQos->vi.txop_flag == 1)
		vi.txop = apSetStaQos->vi.txop;
	if (apSetStaQos->vo.cwmin_flag == 1)
		vo.cwmin = apSetStaQos->vo.cwmin;
	if (apSetStaQos->vo.cwmax_flag == 1)
		vo.cwmax = apSetStaQos->vo.cwmax;
	if (apSetStaQos->vo.aifs_flag == 1)
		vo.aifs = apSetStaQos->vo.aifs;
	if (apSetStaQos->vo.txop_flag == 1)
		vo.txop = apSetStaQos->vo.txop;
	ap_vi_flag = apSetStaQos->vi_flag;
	ap_vo_flag = apSetStaQos->vo_flag;
	ap_be_flag = apSetStaQos->be_flag;
	ap_bk_flag = apSetStaQos->bk_flag;
	apSetStaQosResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_AP_SET_STA_QOS_TLV,  4, (BYTE *)apSetStaQosResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
	return WFA_SUCCESS; 
}

int wfaAPSetAPQos(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caAPSetAPQos_t *apSetAPQos = (caAPSetAPQos_t *) caCmdBuf;
	char *ifname = apSetAPQos->intf;
	dutCmdResponse_t *apSetAPQosResp = &gGenericResp;
    ENTER( __func__ );

   
	apSetAPQosResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_AP_SET_AP_QOS_TLV,  4, (BYTE *)apSetAPQosResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
	return WFA_SUCCESS; 
}

int wfaAPSendADDBAReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caAPSendADDBAReq_t *apSendADDBAReq = (caAPSendADDBAReq_t *) caCmdBuf;
   char *ifname = apSendADDBAReq->intf;
   dutCmdResponse_t *apSendADDBAReqResp = &gGenericResp;
   ENTER( __func__ );

   
   apSendADDBAReqResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_AP_SEND_ADDBA_REQ_TLV,  4, (BYTE *)apSendADDBAReqResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;
   LEAVE( __func__ );
   return WFA_SUCCESS; 
}

int wfaAPSetRfeature(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caAPSetRfeature_t *apSetRfeature = (caAPSetRfeature_t *) caCmdBuf;
    char *ifname = apSetRfeature->intf;
    dutCmdResponse_t *apSetRfeatureResp = &gGenericResp;
    char *str;
    char *nss;
    char *mcs_opt;
    int ret;
    FILE *fp;

   
    printf("\nEntering wfaiAPSetRfeature\n"); 

    if (apSetRfeature->nss_mcs_opt_flag == 1) {
       nss = strtok(apSetRfeature->nss_mcs_opt, ";");
       printf("=>nss  %s\n", nss);
       mcs_opt = strtok(str, "");
       printf("=>mcs_opt  %s\n", mcs_opt);
       if (strcasecmp(nss, "def") == 0 ||
			   strcasecmp(mcs_opt, "def") == 0) {
           if (ap_sgi80_hack != 1) { /* do not do the auto rate configuration if sgi80 is set on AP */
               sprintf(gCmdStr, "./mlanutl uap0 txratecfg 0xff");
           }
       } else
		sprintf(gCmdStr, "./mlanutl uap0 txratecfg 2 %s %s", mcs_opt, nss);
       system_with_log(gCmdStr);
    }
   
    if (apSetRfeature->csa_chnum_band_flag == 1) {

		sprintf(gCmdStr, "%s/%s uap0 channel_switch 1 0 %d 10 4", APP_BIN_LOC,MLANUTL,apSetRfeature->csa_chnum);
		system_with_log(gCmdStr);
		
		   }
  
   apSetRfeatureResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_AP_SET_RFEATURE_TLV,  4, (BYTE *)apSetRfeatureResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS; 
}

int wfaAPSetRadius(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caAPSetRadius_t *apSetRadius = (caAPSetRadius_t *)caCmdBuf;
    dutCmdResponse_t *apSetRadiusResp = &gGenericResp;

    printf("\nEntering %s()\n", __func__);

    if (ap_use_hostapd == 0) {
        printf("Change ap_use_hostapd from 0 to 1\n");
        ap_use_hostapd = 1;
    }

    sprintf(gCmdStr, "cd " HOSTAPD_PATH " ; cp " HOSTAPD_CONF_TEMPLATE " "
        HOSTAPD_CONF_ENT " ;");
    system_with_log(gCmdStr);

    if (apSetRadius->as_ip_flag) {
        printf("AS server ipaddr:%s\n", apSetRadius->as_ip);
        sprintf(gCmdStr, "echo auth_server_addr=%s >> %s",
            apSetRadius->as_ip,   HOSTAPD_CONF_ENT);
        system_with_log(gCmdStr);
    } else {
        printf("AS IP not set, use default from file:%s\n",  
            HOSTAPD_AS_IP_CONF);
        sprintf(gCmdStr, "cat %s >> %s",  
            HOSTAPD_AS_IP_CONF,   HOSTAPD_CONF_ENT);
        system_with_log(gCmdStr);
    }

    if (apSetRadius->as_port_flag) {
        printf("AS server port:%s\n", apSetRadius->as_port);
        sprintf(gCmdStr, "echo auth_server_port=%s >> %s",
            apSetRadius->as_port,   HOSTAPD_CONF_ENT);
        system_with_log(gCmdStr);
    } else {
        printf("AS port not set, use default from file:%s\n",  
            HOSTAPD_AS_PORT_CONF);
        sprintf(gCmdStr, "cat %s >> %s",  
            HOSTAPD_AS_PORT_CONF,   HOSTAPD_CONF_ENT);
        system_with_log(gCmdStr);
    }

    if (apSetRadius->as_passwd_flag) {
        printf("AS server passwd:%s\n", apSetRadius->as_passwd);
        sprintf(gCmdStr, "echo auth_server_shared_secret=%s >> %s",
            apSetRadius->as_passwd,   HOSTAPD_CONF_ENT);
        system_with_log(gCmdStr);
    } else {
        printf("AS passwd not set, use default from file:%s\n",  
            HOSTAPD_AS_PORT_CONF);
        sprintf(gCmdStr, "cat %s >> %s",  
            HOSTAPD_AS_PASSWD_CONF,   HOSTAPD_CONF_ENT);
        system_with_log(gCmdStr);
    }

    apSetRadiusResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_AP_SET_RADIUS_TLV,  4, (BYTE *)apSetRadiusResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}
#endif

int wfaStaBssidPool(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *disc = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *staBssidPoolResp = &gGenericResp;
	ENTER( __func__ );
    
	char *pbssid_pool;
    char *str = NULL;
    char string[256];
    char bssid_list[8][18];
    int  index = 0;
    FILE *tmpfd;

    pbssid_pool = disc->cmdsu.bssid_pool.bssid;
    while (index < 8)
        memset(bssid_list[index++], 0, 18);
    index = 0;

    /** 1. read the file of the 4 BSSIDs */
    tmpfd = fopen("/tmp/bssid_list.txt", "r");
    if(tmpfd != NULL) {
        for(;;) {
            if(fgets(string, 256, tmpfd) == NULL || index >= 8)
                break;
            if(string[0] == '\n')
                continue;
            DPRINT_INFO(WFA_OUT, "Get string from bssid_list.txt - %s\n", string);
            strncpy(bssid_list[index], string, 17);
            bssid_list[index][17] = '\0';
            index++;
        }
        fclose(tmpfd);
    }
	
	tmpfd = fopen("/tmp/bssid_list.txt", "w");
	if(tmpfd == NULL)
	{
		staBssidPoolResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_BSSID_POOL_RESP_TLV, 4, (BYTE *)&staBssidPoolResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + 4;
		DPRINT_ERR (WFA_ERR,"File open failed\n");
		return FALSE;
	}

    /** 2. cmp & store bssid */
    for(;;) {
        str = strtok_r(NULL, " ", &pbssid_pool);
        if(str == NULL || str[0] == '\0')
            break;
        DPRINT_INFO(WFA_OUT, "Bssid_pool - %s\n", str);
        if (disc->cmdsu.bssid_pool.enable == 0) {
            index =  0;
            while (index < 8) {
                if (strncmp(str, bssid_list[index], 17) == 0) {
                    DPRINT_INFO(WFA_OUT, "clear index %d\n", index);
                    bssid_list[index][0] = '\0'; /* clear item */
                    break;
                }
                index ++;
            }
        }
        else if (disc->cmdsu.bssid_pool.enable == 1) {
            index = 0;
            while (index < 8) {
                if (strncmp(bssid_list[index], str, 17) == 0)
                    break;
                DPRINT_INFO(WFA_OUT, "Bssid %d: %s len %d\n", index, bssid_list[index],bssid_list[index][0] );
                if (strlen(bssid_list[index]) == 0) {
                    DPRINT_INFO(WFA_OUT, "Add index %d: %s\n", index, str);
                    strncpy(bssid_list[index], str, 17); /* add item */
                    bssid_list[index][17] = '\0';
                    break;
                }
                index ++;
            }
            if (index == 8) {
                strncpy(bssid_list[0], str, 17); /* update latest to 0 */
                bssid_list[0][17] = '\0';
            }
        }
    }
    if (disc->cmdsu.bssid_pool.enable == 0) {
        fclose(tmpfd);
        system_with_log("rm -f /tmp/bssid_list.txt");
    } else {
        index = 0;
        while(index < 8) {
            fprintf(tmpfd, "%s\n", bssid_list[index]);
            index++;
        }
        fclose(tmpfd);
    }
    staBssidPoolResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_BSSID_POOL_RESP_TLV, 4, (BYTE *)staBssidPoolResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );    
	return TRUE;
}

int wfaStaAddCredential(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *setHS2 = (dutCommand_t *)caCmdBuf;
    caSetHS2_t  *pHS2param;
    dutCmdResponse_t *staSetHS2Resp = &gGenericResp;
	int ret;
	ENTER( __func__ );
    
	mrvl_WS_info->credential_index = get_supplicant_cred_index(mrvl_WS_info->sta_ctrl_interface);
	pHS2param = &setHS2->cmdsu.hs2_param;

	if (pHS2param->prefer) {
		ret = assign_cred_priority(mrvl_WS_info->sta_ctrl_interface,mrvl_WS_info->credential_index,pHS2param->prefer);
	}
	if (pHS2param->cred == SIM) {
	    char imsi[32] = {0};
		char  *pos;
		strncpy(imsi,setHS2->cmdsu.hs2_param.imsi,5);
		strcat(imsi,"-");
		pos = &setHS2->cmdsu.hs2_param.imsi[5];
		strcat(imsi,pos);
		ret = configure_hs2_cred_sim(mrvl_WS_info->sta_ctrl_interface,mrvl_WS_info->credential_index,pHS2param->realm,imsi,setHS2->cmdsu.hs2_param.password);
	} else if (pHS2param->cred == CERT) {
    	/** TODO */
		
    } else if (pHS2param->cred == UNAME_PWD) {
		ret = configure_hs2_cred_uname(mrvl_WS_info->sta_ctrl_interface,mrvl_WS_info->credential_index,pHS2param->realm,pHS2param->home_fdqn,pHS2param->fqdn,pHS2param->username,pHS2param->password,pHS2param->ca);	
	}	
	staSetHS2Resp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_ADD_CREDENTIAL_RESP_TLV, 4, (BYTE *)staSetHS2Resp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
    LEAVE( __func__ );
	return TRUE; 
}

int wfaStaHS2Associate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *assoc = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *staAssocResp = &gGenericResp;
	int ret;

	ENTER( __func__ );
	ret = hs2_supplicant_associate(mrvl_WS_info->sta_ctrl_interface);
	if ( runtime_test_data->dhcp && check_wlan_connectivity(mrvl_dut_info->sta_interface)  == TRUE) {
		invoke_dhcp_client(sta_interface,1);
	}
	ret = get_mlan_bssid_info(mrvl_dut_info->sta_interface,staAssocResp->cmdru.assocInfo.BSSID);	
	ret = get_mlan_essid_info(mrvl_dut_info->sta_interface,staAssocResp->cmdru.assocInfo.SSID);
		
    staAssocResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_HS2_ASSOCIATE_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)staAssocResp, respBuf);   
    *respLen = sizeof(dutCmdResponse_t) + 4;
	LEAVE( __func__ );
    return TRUE; 
}

void wfaStascan(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *stascan = (dutCommand_t *)caCmdBuf;
    caStaScan_t  *pStaScanparam;
    dutCmdResponse_t * staStascanResp= &gGenericResp;
	ENTER( __func__ );
 
	if (!strcasecmp(SIGMA_PROG_NAME,MRVL_HS2_PROG)) {
		set_hs2_network_type(mrvl_WS_info->sta_ctrl_interface,stascan->cmdsu.Stascan_param.hessid,stascan->cmdsu.Stascan_param.accNetType);		
	} 
	
	if ( mrvl_dut_info->use_supplicant ) {
		supplicant_network_scan(mrvl_WS_info->sta_ctrl_interface);			
		sleep(2);			
	} else {
		mlan_network_scan(mrvl_dut_info->sta_interface);
	}
			
    staStascanResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SCAN_RESP_TLV, 4, (BYTE *)staStascanResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
	LEAVE( __func__ );
	return TRUE; 
}

void wfadevSetParameter(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *cmd = (dutCommand_t *)caCmdBuf;
    cadevSetParm_t  *pdevsetparm;
    dutCmdResponse_t * devsetparmResp= &gGenericResp;

 
    devsetparmResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_HS2_DEV_SET_PARAMETER_RESP_TLV, 4, (BYTE *)devsetparmResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
    return TRUE; 
}

void wfaStaResetParm(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *ResetParm = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *staResetParmResp = &gGenericResp;


    staResetParmResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_RESET_PARM_RESP_TLV, 4, (BYTE *)staResetParmResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
    return TRUE; 
}

void wfaStaPolicyUpdate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *policy_update = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *staResetParmResp = &gGenericResp;
    
	staResetParmResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_POLICY_UPDATE_RESP_TLV, 4, (BYTE *)staResetParmResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
    return TRUE; 
}
void wfaStaDevConfigureIe(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *config_ie = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *staDevConfigureIeResp = &gGenericResp;
    DPRINT_INFO(WFA_OUT, "ie_name %s\n", config_ie->cmdsu.devConfigIe.ie_name);
    DPRINT_INFO(WFA_OUT, "ie_contents %s\n", config_ie->cmdsu.devConfigIe.ie_contents);
    sprintf(gCmdStr, "./%s -i %s TEST_ASSOC_IE %s",
            mrvl_WS_info->supplicant_cli_bin,
            mrvl_WS_info->sta_ctrl_interface,
            config_ie->cmdsu.devConfigIe.ie_contents);
    system_with_log(gCmdStr);
    staDevConfigureIeResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_DEV_CONFIGURE_IE_RESP_TLV, 4, (BYTE *)staDevConfigureIeResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
    return TRUE;
}
